<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Investment & Income Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.1.0/chartjs-plugin-annotation.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* FIX: Global Box Sizing */
        * { box-sizing: border-box; }

        /* =========================================
           GLOBAL VARIABLES (Default = Light Mode)
           ========================================= */
        :root {
            /* Colors */
            --primary: #2c3e50;
            --success: #27ae60;
            --danger: #c0392b;
            --bg: #ecf0f1;
            --card-bg: rgba(255, 255, 255, 0.9); /* Slight transparency for light mode too */
            --text: #2c3e50;
            --accent: #8e44ad;
            --goal: #e67e22;
            --border-color: rgba(0,0,0,0.1); /* Darker border for visibility without shadow */
            --crosshair-color: rgba(0,0,0,0.2); /* Tech decoration color */
            --th-bg: rgba(0,0,0,0.03);
            --hover-bg: rgba(0,0,0,0.02);
            
            /* Fonts & Structure */
            --font-main: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        
        /* =========================================
           SCI-FI / DARK MODE OVERRIDES (Colors Only)
           ========================================= */
        body.sci-fi-mode {
            --primary: #bdc3c7;
            --success: #00ff88; /* Neon Green */
            --danger: #ff4757;  /* Neon Red */
            --bg: #050505;      /* Deep Space Black */
            --card-bg: rgba(20, 20, 20, 0.65); /* Glassy Dark */
            --text: #ecf0f1;
            --accent: #a29bfe;
            --goal: #fab1a0;
            --border-color: rgba(255,255,255,0.15);
            --crosshair-color: rgba(255,255,255,0.2);
            --th-bg: rgba(255,255,255,0.1);
            --hover-bg: rgba(255,255,255,0.05);
        }

        /* Specific text color overrides for visibility in dark mode */
        body.sci-fi-mode .text-green { color: #00ff88 !important; }
        body.sci-fi-mode .text-red { color: #ff4757 !important; }
        body.sci-fi-mode .text-purple { color: #a29bfe !important; }
        body.sci-fi-mode .account-name { color: #fff; }
        body.sci-fi-mode .sub-text { color: #95a5a6; }
        body.sci-fi-mode .ticker-tag { color: #3498db; border: 1px solid #3498db; }

        /* Chart adjustments for transparency in dark mode */
        body.sci-fi-mode canvas {
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.1));
        }

        /* =========================================
           GLOBAL STRUCTURAL STYLES (Matches Sci-Fi Layout)
           ========================================= */
        
        html, body { overflow-x: hidden; }

        body {
            font-family: var(--font-main);
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* WIDER CONTAINER (Standardized) */
        .container { 
            max-width: 1600px; 
            margin: 0 auto; 
            width: 100%; 
            transition: max-width 0.5s ease; 
        }
        
        /* TECH LOOK FOR CARDS (Sharp corners, borders, decorations) */
        .card, 
        .stat-card,
        header {
            border-radius: 0px; /* Sharp technical corners */
            border: 1px solid var(--border-color);
            box-shadow: none; /* Removed shadow for flat tech look */
            background: var(--card-bg);
            backdrop-filter: blur(10px); /* Frosted glass look */
            position: relative;
        }

        /* TECH DECORATION: Corner Crosshairs */
        .card::before {
            content: '+';
            position: absolute;
            top: 5px; right: 8px;
            color: var(--crosshair-color);
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
        }

        /* TYPOGRAPHY (Uppercase Technical Headers) */
        h1, h3, .section-header {
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 300; /* Lighter weight for tech look */
        }

        h1 { margin: 0; font-size: 24px; color: var(--primary); line-height: 1.2; }
        
        .section-header {
            margin: 40px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
            color: var(--primary);
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: space-between; 
            gap: 10px;
            flex-wrap: wrap;
        }

        .stat-value {
            letter-spacing: -1px;
        }

        /* =========================================
           COMPONENT STYLES
           ========================================= */

        /* FLOATING STATUS BOX */
        .status-floater {
            position: fixed;
            background: var(--card-bg);
            padding: 10px 15px;
            border-radius: 0px; /* Sharp corners here too */
            border: 1px solid var(--border-color);
            z-index: 998;
            backdrop-filter: blur(5px);
            text-align: right;
            will-change: top, left; 
        }

        /* UTILITY: DISABLE TRANSITION FOR IMMEDIATE UPDATES */
        .status-floater.no-transition {
            transition: none !important;
        }

        /* THEME TOGGLE BUTTON */
        .theme-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 32px;  
            height: 32px; 
            background: var(--primary);
            color: white; /* Always white icon on colored button */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 999;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border: 2px solid white;
            transition: transform 0.2s;
        }
        .theme-toggle:hover { transform: scale(1.1); }
        .theme-toggle svg { width: 16px; height: 16px; fill: currentColor; }

        /* Headers Layout */
        header {
            margin-bottom: 20px;
            padding: 20px;
            display: flex;
            flex-direction: row; 
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        header > div:first-child { width: auto; }
        #status-placeholder { width: 260px; height: 50px; pointer-events: none; flex-shrink: 0; }
        
        .subtitle { color: #7f8c8d; font-size: 0.9em; margin-top: 5px; letter-spacing: 0.5px; }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            padding: 20px;
            /* Left colored borders removed */
            min-width: 0; 
        }
        
        .stat-label { font-size: 0.85em; color: #7f8c8d; text-transform: uppercase; letter-spacing: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .stat-value { font-size: 1.8em; font-weight: 700; color: var(--primary); margin-top: 5px; word-break: break-word; }
        .stat-sub { font-size: 0.85em; margin-top: 5px; color: #7f8c8d; }
        .text-green { color: var(--success); }
        .text-red { color: var(--danger); }
        .text-purple { color: var(--accent); }

        /* Cards General */
        .card { padding: 20px; margin-bottom: 20px; width: 100%; min-width: 0; }
        .card h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1em; color: var(--text); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        
        /* Charts */
        .charts-row { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 30px; }
        .chart-container { position: relative; height: 350px; width: 100%; }
        .chart-container-tall { height: 480px; }
        .chart-container-small { height: 200px; } 

        /* TradingView */
        .tv-card { height: 850px; margin-bottom: 50px; overflow: hidden; display: flex; flex-direction: column; padding: 0; }
        .tv-card h3 { padding: 20px; margin: 0; flex-shrink: 0; }
        .tv-widget-container { flex-grow: 1; width: 100%; height: auto; }

        /* Tables (Tech Style) */
        .table-responsive { width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; }
        table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        
        th, td { 
            padding: 8px 10px; 
            text-align: right; 
            border-bottom: 1px solid var(--border-color); 
            white-space: nowrap; 
        }
        th:first-child, td:first-child { text-align: left; }
        
        th { 
            background-color: var(--th-bg); 
            color: var(--primary); /* Uses theme primary */
            text-transform: uppercase; 
            font-size: 0.75em; 
            letter-spacing: 1px;
            font-weight: 600; 
        }
        tr:hover { background-color: var(--hover-bg); }
        
        .table-compact th, .table-compact td { padding: 5px 6px; font-size: 0.85em; }

        .ticker-tag {
            background: rgba(41, 128, 185, 0.1);
            color: #2980b9;
            padding: 2px 6px;
            border-radius: 4px; /* Tag remains rounded for contrast */
            font-size: 0.85em;
            font-weight: 600;
            display: inline-block;
        }

        .account-name { font-weight: 500; display: block; }
        .sub-text { font-size: 0.75em; color: #999; display: block; margin-top: 2px; }
        
        /* Controls */
        .filter-group {
            display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;
            background: var(--hover-bg);
            padding: 10px;
            border-radius: 4px; /* Slight rounding for controls */
            border: 1px solid var(--border-color);
        }
        .filter-label { font-size: 0.85em; font-weight: bold; color: #7f8c8d; margin-right: 10px; align-self: center; }
        .checkbox-item { display: flex; align-items: center; font-size: 0.85em; cursor: pointer; color: var(--text); }
        .checkbox-item input { margin-right: 6px; }
        .radio-label { display: flex; align-items: center; cursor: pointer; color: var(--text); font-size: 0.85em; }
        .radio-label input { margin-right: 6px; cursor: pointer; }
        .radio-label:hover { color: var(--accent); }

        /* Loading Overlay */
        #loading {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000; font-weight: bold; color: var(--primary);
            text-align: center;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.3s ease;
        }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
        .live-dot {
            height: 8px; width: 8px; 
            background-color: var(--danger); 
            border-radius: 50%; 
            display: inline-block; 
            margin-right: 5px;
            animation: pulse 1.5s infinite;
        }

        /* RESPONSIVE */
        @media (max-width: 900px) { 
            .charts-row { grid-template-columns: 1fr; } 
        }

        @media (max-width: 768px) {
            body { padding: 5px; }
            .status-floater.mobile-dock { top: 70px !important; left: auto !important; right: 10px !important; padding: 6px 12px; }
            header { padding: 15px; flex-direction: column; align-items: flex-start; }
            header > div:first-child { width: 100%; }
            #status-placeholder { width: 100%; height: 50px; margin-top: 10px; }
            .stats-grid { grid-template-columns: 1fr 1fr; gap: 10px; } 
            .stat-card { padding: 12px 10px; }
            .stat-value { font-size: 1.4em; }
            .stat-label { font-size: 0.7em; }
            .tv-card { height: 650px !important; }
            .chart-container { height: 250px !important; }
            .chart-container-tall { height: 550px !important; }
            .card { padding: 10px 5px; margin-bottom: 15px; }
            th, td { padding: 8px 4px; font-size: 0.75em; }
            .table-responsive { display: block; width: 100%; overflow-x: auto; }
            select#extrapolationRateSelect { max-width: 100%; font-size: 0.8em; }
        }
    </style>
</head>
<body class="sci-fi-mode"> <div id="loading">Loading Dashboard Data...</div>

<div class="theme-toggle" onclick="toggleTheme()" title="Switch View">
    <svg viewBox="0 0 24 24">
        <path d="M12,18C11.11,18 10.26,17.8 9.5,17.45C11.56,16.55 13,14.43 13,12C13,9.57 11.56,7.45 9.5,6.55C10.26,6.2 11.11,6 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z" />
    </svg>
</div>

<div id="status-floater" class="status-floater" style="top: -100px; left: 0;">
    <div style="font-size: 0.9em; font-weight: bold; color: var(--danger);" id="latest-date-display">
        <span class="live-dot"></span>Connecting...
    </div>
    <div id="refresh-timer" style="font-size: 0.75em; color: #999; margin-top: 4px;">Updates in 60s</div>
</div>

<div class="container">
    <header>
        <div>
            <h1>Financial Dashboard</h1>
            <div class="subtitle">Investment Portfolio & Compensation Analysis</div>
        </div>
        <div id="status-placeholder"></div>
    </header>

    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-label">Total Net Worth</div>
            <div class="stat-value" id="stat-networth">-</div>
            <div class="stat-sub">Across all accounts</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Lifetime Gain</div>
            <div class="stat-value" id="stat-lifetime-gain">-</div>
            <div class="stat-sub">Cumulative Returns</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Latest Monthly P&L</div>
            <div class="stat-value" id="stat-monthly-pl">-</div>
            <div class="stat-sub">Market Change + Income</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Inflow (Latest)</div>
            <div class="stat-value" id="stat-monthly-inflow">-</div>
            <div class="stat-sub" id="stat-monthly-inflow-sub">-</div>
        </div>
    </div>

    <div class="card">
        <h3>Balance History (Stacked)</h3>
        <div class="chart-container chart-container-tall">
            <canvas id="balanceChart"></canvas>
        </div>
    </div>
    
    <div class="card tv-card">
        <h3>Live Market Watch (Your Positions)</h3>
        <div class="tv-widget-container" id="tv-widget-container"></div>
    </div>

    <div class="charts-row">
        <div class="card">
            <h3>Current Investment Breakdown (Latest Month)</h3>
            <div class="table-responsive">
                <table id="snapshotTable" class="table-compact">
                    <thead>
                        <tr>
                            <th>Account</th>
                            <th>Balance</th>
                            <th>1-Mo Gain</th>
                            <th>1-Mo Inflow</th> 
                            <th>Net Dep</th>
                            <th>Return</th>
                            <th>ROI</th> </tr>
                    </thead>
                    <tbody id="snapshotBody"></tbody>
                </table>
            </div>
            
            <h3 style="margin-top: 30px; border-top: 2px solid var(--border-color); padding-top: 20px;">Previous Month Breakdown</h3>
            <div class="table-responsive">
                <table id="prevSnapshotTable" class="table-compact">
                    <thead>
                        <tr>
                            <th>Account</th>
                            <th>Balance</th>
                            <th>1-Mo Gain</th>
                            <th>1-Mo Inflow</th> 
                            <th>Net Dep</th>
                            <th>Return</th>
                            <th>ROI</th> </tr>
                    </thead>
                    <tbody id="prevSnapshotBody"></tbody>
                </table>
            </div>
        </div>
        
        <div class="card">
            <h3>Asset Allocation</h3>
            <div class="chart-container">
                <canvas id="allocationChart"></canvas>
            </div>
        </div>
    </div>

    <div class="card">
        <h3>Monthly Profit/Loss Analysis (Investments)</h3>
        <div class="chart-container">
            <canvas id="plChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3>Wells Fargo Monthly Withdrawals (Last 24 Months)</h3>
        <div class="chart-container chart-container-small">
            <canvas id="wfWithdrawalChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3>Investment History Details</h3>
        <div class="table-responsive" style="max-height: 400px;">
            <table id="historyTable" class="table-compact">
                <thead>
                    <tr id="historyHeader">
                        <th>Month</th>
                        <th>Total Balance</th>
                        <th>Total Gain/Loss</th>
                        </tr>
                </thead>
                <tbody id="historyBody"></tbody>
            </table>
        </div>
    </div>

    <div class="section-header">
        Compensation History
    </div>

    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-label">Latest Base Salary</div>
            <div class="stat-value" id="stat-salary-base">-</div>
            <div class="stat-sub" id="stat-salary-date">As of -</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Proj. Total Comp (2025)</div>
            <div class="stat-value" id="stat-total-comp">-</div>
            <div class="stat-sub">Base + Match + Bonus + Edu</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Education Benefits (YTD)</div>
            <div class="stat-value" id="stat-edu-ytd">-</div>
            <div class="stat-sub">Tuition Reimbursement</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Match Rate</div>
            <div class="stat-value" id="stat-match-rate">-</div>
            <div class="stat-sub">Of Base Salary</div>
        </div>
    </div>

    <div class="charts-row">
        <div class="card">
            <h3>Salary vs. Total Compensation Trends (Stacked)</h3>
            <div class="chart-container">
                <canvas id="salaryTrendChart"></canvas>
            </div>
        </div>
        <div class="card">
            <h3>Compensation Components (Latest YTD)</h3>
            <div class="chart-container">
                <canvas id="compBreakdownChart"></canvas>
            </div>
        </div>
    </div>

    <div class="card" style="padding-bottom:10px;">
        <h3 style="margin-bottom:10px">Income Analysis Controls</h3>
        <div class="filter-group" id="income-filter-container">
            <span class="filter-label">Include Deposits From:</span>
            </div>
    </div>

    <div class="card" style="display:flex; align-items:center; justify-content:space-between; background:var(--bg);">
        <div>
            <h3 style="margin:0; border:none; padding:0;">Trailing 12-Month After-Tax Income</h3>
            <div class="subtitle">Total liquid deposits (Based on selection above)</div>
        </div>
        <div style="text-align:right;">
             <div style="font-size:2em; font-weight:bold; color:var(--success);" id="stat-12mo-income">-</div>
             <div style="font-size:0.8em; color:#7f8c8d;">Last 12 Months</div>
        </div>
    </div>

    <div class="card">
        <h3>Monthly After-Tax Income (Last 24 Months)</h3>
        <div class="subtitle" style="margin-bottom:15px">Sum of deposits for selected accounts</div>
        <div class="chart-container">
            <canvas id="incomeTrendChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3>Compensation History Details</h3>
        <div class="table-responsive" style="max-height: 400px;">
            <table id="salaryTable" class="table-compact">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Base Salary</th>
                        <th>Match</th>
                        <th>Bonus</th>
                        <th>Education</th>
                        <th>Total Comp</th>
                    </tr>
                </thead>
                <tbody id="salaryBody"></tbody>
            </table>
        </div>
    </div>

    <div class="card" style="padding-bottom:10px;">
        <h3 style="margin-bottom:10px">+25 Year Extrapolation Controls</h3>
        
        <div class="filter-group" style="margin-bottom: 10px;">
            <span class="filter-label">Payday Anchor (Bi-weekly):</span>
            <input type="date" id="paydayAnchor" value="2026-01-10" style="padding:5px; border-radius:4px; border:1px solid #ccc; font-family:inherit;" onchange="updateAllProjections()">
        </div>

        <div class="filter-group">
            <span class="filter-label">Select Annual Return:</span>
            
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.05" onchange="updateAllProjections()"> 5%
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.075" onchange="updateAllProjections()"> 7.5%
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.1" checked onchange="updateAllProjections()"> 10% (Baseline)
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.125" onchange="updateAllProjections()"> 12.5%
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.15" onchange="updateAllProjections()"> 15%
            </label>
        </div>
    </div>

    <div class="stats-grid">
         <div class="stat-card">
            <div class="stat-label" id="card-nw-label">Projected Net Worth (10%)</div>
            <div class="stat-value" id="proj-nw-card">-</div>
            <div class="stat-sub">In 25 Years</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Porsche Purchase</div>
            <div style="font-size:0.9em; font-weight:bold; margin-top:4px; color:var(--text);">$3M Goal</div>
            <div style="font-size:0.9em; font-weight:bold; color:var(--danger);">$300k Cost</div>
            <div class="stat-value" id="proj-porsche-date">-</div>
            <div class="stat-sub" id="proj-porsche-countdown" style="font-weight:bold; color:var(--primary); font-size:0.9em; margin-bottom:2px">-</div>
            <div class="stat-sub" id="proj-porsche-sub">Estimated Date</div>
        </div>
         <div class="stat-card">
            <div class="stat-label">Beach House</div>
            <div style="font-size:0.9em; font-weight:bold; margin-top:4px; color:var(--text);">$10M Goal</div>
            <div style="font-size:0.9em; font-weight:bold; color:var(--danger);">$5M Cost</div>
            <div class="stat-value" id="proj-house-date">-</div>
            <div class="stat-sub" id="proj-house-countdown" style="font-weight:bold; color:var(--primary); font-size:0.9em; margin-bottom:2px">-</div>
            <div class="stat-sub" id="proj-house-sub">Estimated Date</div>
        </div>
    </div>

    <div class="card">
        <h3>Net Worth Projection (Range: 5% - 15% Annual Return)</h3>
        <div id="chart-subtitle-text" style="text-align: center; font-size: 0.85em; color: #7f8c8d; margin-bottom: 10px;">
            Baseline: Current Net Worth + Bi-Weekly Contributions (Derived from latest inflow)
        </div>
        <div class="chart-container chart-container-tall">
            <canvas id="projectionChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3 style="margin-bottom:15px; border-bottom:1px solid var(--border-color); padding-bottom:10px;">Detailed Projection Breakdown</h3>
        
        <div style="background:var(--bg); padding:15px; border-radius:6px; margin-bottom:20px; font-size:0.9em; line-height:1.6; color:var(--text); border:1px solid var(--border-color);">
            <strong>The Math Behind the Numbers:</strong><br>
            Future values are calculated monthly using the formula: 
            <code style="background:var(--card-bg); padding:2px 4px; border-radius:3px; color:var(--danger); font-family:monospace; word-break: break-word;">Balance(t) = Balance(t-1) Ã— (1 + AnnualRate/12) + MonthlyInflow(t)</code>.<br>
            <strong>Contribution Assumptions:</strong>
            Contributions are calculated <strong>bi-weekly (every 14 days)</strong> based on the selected Payday Anchor. Most months have 2 contributions, while some have 3. 
            <br>
            Raises are applied to the base paycheck amount: 
            <strong><span id="jan-raise-display">6.0%</span> every January</strong> and 
            <strong><span id="july-raise-display">3.0%</span> every July</strong> 
            (Auto-calculated from your most recent salary history).
        </div>
    
        <div class="table-responsive" style="max-height: 500px;">
            <table id="projectionTable" class="table-compact">
                <thead>
                    <tr>
                        <th style="width:10%">Year</th>
                        <th style="width:20%">Start Balance</th>
                        <th style="width:25%">Annual Contribution</th>
                        <th style="width:25%">Est. Market Growth</th>
                        <th style="width:20%">End Balance</th>
                    </tr>
                </thead>
                <tbody id="projectionTableBody"></tbody>
            </table>
        </div>
    </div>

</div>

<script>
    // ==========================================
    // FLUID STATUS BOX POSITIONING LOGIC
    // ==========================================
    let isDockedState = false; 
    let scrollRaf = null;

    function onScroll() {
        if (!scrollRaf) {
            scrollRaf = requestAnimationFrame(() => {
                updateStatusPosition();
                scrollRaf = null;
            });
        }
    }

    function updateStatusPosition() {
        const floater = document.getElementById('status-floater');
        const placeholder = document.getElementById('status-placeholder');
        if (!floater || !placeholder) return;

        const scrollY = window.scrollY;
        const threshold = 50; 
        const isMobile = window.innerWidth <= 768;

        const dockTop = isMobile ? 70 : 20;
        const dockRight = isMobile ? 10 : 80;
        const fWidth = floater.offsetWidth || 200; 
        const dockLeft = window.innerWidth - dockRight - fWidth;

        const shouldDock = scrollY > threshold;

        if (shouldDock) {
            // DOCKED MODE
            floater.style.top = dockTop + 'px';
            floater.style.left = dockLeft + 'px';
            
            if (!isDockedState) {
                // Animate INTO the docked position
                floater.style.transition = 'top 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), left 0.5s cubic-bezier(0.2, 0.8, 0.2, 1)';
                isDockedState = true;
                floater.classList.add('mobile-dock');
            }
        } else {
            // EMBEDDED MODE
            const pRect = placeholder.getBoundingClientRect();
            
            floater.style.top = pRect.top + 'px';
            floater.style.left = (pRect.left + (isMobile ? 0 : 0)) + 'px';
            
            if (isDockedState) {
                // SWITCHING BACK: Snap instantly to feel "sticky" and rigid
                floater.style.transition = 'none';
                isDockedState = false;
                floater.classList.remove('mobile-dock');
            } else {
                // SCROLLING: Keep transition disabled to track perfectly
                floater.style.transition = 'none';
            }
        }
    }

    // Initialization Safety Check
    function initStatusFloater() {
        updateStatusPosition();
        // Recalculate after a short delay to ensure layout/fonts are settled
        setTimeout(updateStatusPosition, 100);
        setTimeout(updateStatusPosition, 500);
    }

    // Bind Events
    window.addEventListener('scroll', onScroll);
    window.addEventListener('resize', onScroll);
    window.addEventListener('DOMContentLoaded', initStatusFloater);
    window.onload = initStatusFloater;


    // ==========================================
    // THEME HANDLING
    // ==========================================
    let isSciFiMode = true; // Changed default variable

    // GLOBAL PALETTE DEFINITION - Used everywhere for consistency
    const palette = ['#3498db', '#9b59b6', '#2ecc71', '#e67e22', '#f1c40f', '#e74c3c'];

    // RAISE CALCULATION GLOBALS
    let globalJanRaise = 0.06;
    let globalJulyRaise = 0.03;

    function toggleTheme() {
        isSciFiMode = !isSciFiMode;
        document.body.classList.toggle('sci-fi-mode');
        
        // Reload TradingView with correct theme
        initTradingView(isSciFiMode ? "dark" : "light");
        
        // Update Chart.js Styles
        updateChartStyles();
        
        // Force Re-render of tables to apply new background color logic immediately
        if(globalAccountsData && globalAccountsData.length > 0) {
            processAndRender(globalAccountsData, true);
        }
        
        // Temporarily disable transition during theme switch to prevent floating
        const floater = document.getElementById('status-floater');
        if(floater) floater.style.transition = 'none';
        
        updateStatusPosition();
    }

    function hexToRgba(hex, alpha) {
        let r = parseInt(hex.slice(1, 3), 16),
            g = parseInt(hex.slice(3, 5), 16),
            b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function updateChartStyles() {
        // Set Global Chart Defaults so new elements inherit correctly
        Chart.defaults.color = isSciFiMode ? '#ecf0f1' : '#2c3e50';
        Chart.defaults.borderColor = isSciFiMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

        const textColor = isSciFiMode ? '#ecf0f1' : '#2c3e50';
        const gridColor = isSciFiMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        const alphaFill = isSciFiMode ? 0.3 : 0.6; 

        Object.values(charts).forEach(chart => {
            if (!chart) return;

            // Update Scales
            if (chart.options.scales) {
                ['x', 'y'].forEach(axis => {
                    if (chart.options.scales[axis]) {
                        if (chart.options.scales[axis].ticks) chart.options.scales[axis].ticks.color = textColor;
                        if (chart.options.scales[axis].grid) chart.options.scales[axis].grid.color = gridColor;
                        if (chart.options.scales[axis].title) chart.options.scales[axis].title.color = textColor;
                    }
                });
            }

            // Update Plugins (Legend, Title, Datalabels)
            if (chart.options.plugins) {
                if (chart.options.plugins.legend) {
                     chart.options.plugins.legend.labels.color = textColor;
                }
                if (chart.options.plugins.title) {
                    chart.options.plugins.title.color = textColor;
                }
                if (chart.options.plugins.datalabels) {
                    chart.options.plugins.datalabels.color = textColor;
                }
            }
            
            // SPECIFIC FIX FOR BALANCE CHART LABELS
            if (chart.canvas.id === 'balanceChart') {
                if (chart.options.plugins && chart.options.plugins.datalabels) {
                    if (isSciFiMode) {
                        // Dark Mode: Colored Background, White Text
                        chart.options.plugins.datalabels.backgroundColor = function(context) {
                            return context.dataset.backgroundColor;
                        };
                        chart.options.plugins.datalabels.borderColor = function(context) {
                            return context.dataset.borderColor;
                        };
                        chart.options.plugins.datalabels.color = '#ffffff'; 
                    } else {
                        // Light Mode: White Background, Black Text
                        chart.options.plugins.datalabels.backgroundColor = 'white';
                        chart.options.plugins.datalabels.borderColor = function(context) {
                            return context.dataset.borderColor;
                        };
                        chart.options.plugins.datalabels.color = 'black';
                    }
                }
            } else {
                 // General Datalabels update for other charts (text color only)
                 if (chart.options.plugins && chart.options.plugins.datalabels) {
                    chart.options.plugins.datalabels.color = textColor;
                }
            }

            // Update Datasets (Transparency)
            chart.data.datasets.forEach(dataset => {
                if (dataset.backgroundColor && typeof dataset.backgroundColor === 'string' && dataset.backgroundColor.startsWith('#')) {
                    // This handles simple hex codes, but our logic often uses palette vars
                    // The main chart logic below forces hex+88, so we let the main logic handle colors
                } 
            });

            chart.update();
        });
    }


    // ==========================================
    // DATA SOURCES
    // ==========================================
    
    const API_URL = 'https://script.google.com/macros/s/AKfycbxEzEutSYlhftlhNq_EI-dJRwARlcB00enAAm_9pkDxX5m8mhdtr8OsRx1rzneN4gXy/exec';

    const TICKER_MAP = {
        'VIGIX': 'VIGIX',
        'VTSAX': 'VTSAX',
        'GOOGL': 'GOOGL',
        'Fidelity (GOOGL)': 'GOOGL',
        'Boeing (Bonds)': 'BND',    
        'Wells Fargo (Cash)': 'BIL' 
    };

    let projectionDataStore = {};
    let projectionMetadata = {}; 
    let globalAccountsData = []; 
    let charts = {};

    let refreshInterval = null;
    let refreshTimer = 60;

    // ==========================================
    // UTILITIES
    // ==========================================
    const isMobile = window.innerWidth <= 768;

    function cleanMoney(str) {
        if (!str) return 0;
        const s = String(str).replace(/[$,"]/g, '').trim();
        return parseFloat(s) || 0;
    }

    function cleanPercent(str) {
        if (!str) return 0;
        const s = String(str).replace(/[%"]/g, '').trim();
        return parseFloat(s) || 0;
    }

    function fmtMoney(num) {
        return '$' + num.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function fmtMoneySimple(num) {
        return '$' + num.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
    }

    function formatCountdown(targetDate) {
        if (!targetDate) return "N/A";
        const now = new Date();
        if (targetDate <= now) return "Achieved!";
        let years = targetDate.getFullYear() - now.getFullYear();
        let months = targetDate.getMonth() - now.getMonth();
        if (months < 0) { years--; months += 12; }
        return `${years} Years, ${months} Months remaining`;
    }

    // ==========================================
    // LOGIC: REAL-TIME MARKET DATA
    // ==========================================

    async function getMonthToDatePerformance(ticker) {
        if (!ticker || ticker === 'Unknown' || ticker === '-') return 0;
        const cleanTicker = TICKER_MAP[ticker] || ticker.split(' ')[0]; 

        const proxies = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/get?url=',
            'https://thingproxy.freeboard.io/fetch/' 
        ];

        const cacheBuster = `&_=${new Date().getTime()}`;
        const targetUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${cleanTicker}?range=3mo&interval=1d${cacheBuster}`;

        for (const proxy of proxies) {
            try {
                let fetchUrl = '';
                if (proxy.includes('allorigins')) {
                    fetchUrl = proxy + encodeURIComponent(targetUrl);
                } else {
                    fetchUrl = proxy + targetUrl;
                }

                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error('Network response was not ok');
                
                let data;
                if (proxy.includes('allorigins')) {
                    const wrapper = await response.json();
                    data = JSON.parse(wrapper.contents);
                } else {
                    data = await response.json();
                }

                if (!data.chart || !data.chart.result || data.chart.result.length === 0) continue;

                const quote = data.chart.result[0];
                const timestamps = quote.timestamp;
                const closes = quote.indicators.quote[0].close;

                if (!closes || closes.length === 0) continue;

                const now = new Date();
                const startOfCurrentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                
                let baselinePrice = null;
                for (let i = timestamps.length - 1; i >= 0; i--) {
                    const date = new Date(timestamps[i] * 1000);
                    if (date < startOfCurrentMonth && closes[i]) {
                        baselinePrice = closes[i]; 
                        break;
                    }
                }

                let currentPrice = null;
                for (let i = closes.length - 1; i >= 0; i--) {
                    if (closes[i] !== null && closes[i] !== undefined) {
                        currentPrice = closes[i];
                        break;
                    }
                }

                if (!baselinePrice || !currentPrice) return 0;
                
                return (currentPrice - baselinePrice) / baselinePrice;

            } catch (e) {
                console.warn(`Proxy ${proxy} failed for ${cleanTicker}:`, e);
            }
        }
        return null; 
    }

    async function updateWithLiveMarketData(accounts, isSilent = false) {
        const statusDiv = document.getElementById('loading');
        const headerStatus = document.getElementById('latest-date-display');
        
        if (!isSilent) {
            statusDiv.style.opacity = '1';
            statusDiv.style.display = 'flex';
            statusDiv.innerHTML = "Fetching Real-Time Market Data...<br><span style='font-size:0.8em; font-weight:normal'>Trying multiple sources...</span>";
        } else {
            headerStatus.innerHTML = "<span class='live-dot'></span> Updating Market Data...";
            headerStatus.style.color = "#e67e22";
        }
        
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonthVal = now.getMonth() + 1; 
        const currentMonthKey = `${currentYear}-${String(currentMonthVal).padStart(2, '0')}`;
        
        await Promise.all(accounts.map(async (acc) => {
            if (acc.data.length === 0) return;

            const startOfThisMonth = new Date(currentYear, currentMonthVal - 1, 1);
            let baselineEntry = null;
            for (let i = acc.data.length - 1; i >= 0; i--) {
                if (acc.data[i].dateObj < startOfThisMonth) {
                    baselineEntry = acc.data[i];
                    break;
                }
            }

            if (!baselineEntry) return;

            let liveEntry = acc.data.find(d => d.key === currentMonthKey);
            let isNewRow = false;

            if (!liveEntry) {
                isNewRow = true;
                liveEntry = {
                    key: currentMonthKey,
                    dateObj: startOfThisMonth,
                    deposits: 0,
                    income: 0,
                    marketGain: 0,
                    cumulative: baselineEntry.cumulative,
                    balance: baselineEntry.balance,
                    invested: baselineEntry.invested,
                    rawWithdrawals: 0, 
                    isLive: true,
                    isError: false 
                };
            } else {
                liveEntry.isLive = true;
                liveEntry.isError = false;
            }

            let ticker = liveEntry.invested; 
            if (acc.id.includes('fidelity')) ticker = 'GOOGL';
            if (acc.id.includes('boeing')) ticker = 'Boeing (Bonds)';
            if (acc.id.includes('wells')) ticker = 'Wells Fargo (Cash)';

            const mtdGrowthRate = await getMonthToDatePerformance(ticker);
            
            if (mtdGrowthRate === null) {
                liveEntry.isError = true;
                if (isNewRow) {
                    liveEntry.marketGain = 0;
                    liveEntry.balance = baselineEntry.balance + liveEntry.deposits + liveEntry.income;
                }
            } else {
                const growthAmount = baselineEntry.balance * mtdGrowthRate;
                liveEntry.marketGain = growthAmount; 
                liveEntry.balance = baselineEntry.balance + growthAmount + liveEntry.deposits + liveEntry.income;
                liveEntry.cumulative = baselineEntry.cumulative + growthAmount + liveEntry.income;
            }

            if (isNewRow) {
                acc.data.push(liveEntry);
            }
        }));
    }

    // ==========================================
    // LOGIC: SALARY 
    // ==========================================
    function processSalaryData(rows) {
        if (!rows || rows.length < 2) {
            document.getElementById('stat-salary-base').innerText = "No Data";
            return;
        }

        const data = rows.slice(1).map(r => ({
            year: r[0], date: r[1],
            salary: cleanMoney(r[2]), matchPct: cleanPercent(r[3]), matchAmt: cleanMoney(r[4]),
            bonus: cleanMoney(r[5]), ytdBonus: cleanMoney(r[6]),
            edu: cleanMoney(r[7]), ytdEdu: cleanMoney(r[8]),
            recurring: cleanMoney(r[9]), totalComp: cleanMoney(r[11])
        }));

        data.sort((a,b) => new Date(a.date) - new Date(b.date));
        
        // --- AUTO-CALCULATE RECENT RAISES ---
        const now = new Date();
        const currentYear = now.getFullYear();

        let targetJan = new Date(currentYear, 0, 1);
        if (now < targetJan) targetJan = new Date(currentYear - 1, 0, 1); 

        let targetJuly = new Date(currentYear, 6, 1);
        if (now < targetJuly) targetJuly = new Date(currentYear - 1, 6, 1);

        let closestJanEntry = null;
        let minJanDiff = Infinity;
        let closestJanIndex = -1;

        let closestJulyEntry = null;
        let minJulyDiff = Infinity;
        let closestJulyIndex = -1;

        data.forEach((d, index) => {
            const dDate = new Date(d.date);
            const diffJan = Math.abs(dDate - targetJan);
            const diffJuly = Math.abs(dDate - targetJuly);
            
            if (diffJan < minJanDiff) { minJanDiff = diffJan; closestJanEntry = d; closestJanIndex = index; }
            if (diffJuly < minJulyDiff) { minJulyDiff = diffJuly; closestJulyEntry = d; closestJulyIndex = index; }
        });

        if (closestJanIndex > 0) {
            const prev = data[closestJanIndex - 1];
            if (prev.salary > 0) globalJanRaise = (closestJanEntry.salary - prev.salary) / prev.salary;
        }
        if (closestJulyIndex > 0) {
            const prev = data[closestJulyIndex - 1];
            if (prev.salary > 0) globalJulyRaise = (closestJulyEntry.salary - prev.salary) / prev.salary;
        }
        
        // Update UI Text in Breakdown
        const janPctText = (globalJanRaise * 100).toFixed(1) + '%';
        const julyPctText = (globalJulyRaise * 100).toFixed(1) + '%';
        document.getElementById('jan-raise-display').innerText = janPctText;
        document.getElementById('july-raise-display').innerText = julyPctText;
        
        // Update Chart Subtitle
        const chartSub = document.getElementById('chart-subtitle-text');
        if(chartSub) {
            chartSub.innerHTML = `Baseline: Current Net Worth + Bi-Weekly Contributions (Raises: <strong>${janPctText}</strong> Jan, <strong>${julyPctText}</strong> July)`;
        }

        // --- END AUTO-CALCULATION ---

        if (data.length === 0) return;
        const latest = data[data.length - 1];
        
        document.getElementById('stat-salary-base').innerText = fmtMoney(latest.salary);
        document.getElementById('stat-salary-date').innerText = "Effective: " + latest.date;
        document.getElementById('stat-total-comp').innerText = fmtMoney(latest.totalComp);
        document.getElementById('stat-edu-ytd').innerText = fmtMoney(latest.ytdEdu || 0);
        document.getElementById('stat-match-rate').innerText = latest.matchPct + "%";

        const tbody = document.getElementById('salaryBody');
        tbody.innerHTML = '';
        [...data].reverse().forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td style="white-space:nowrap">${row.date}</td>
                <td style="font-weight:bold">${fmtMoney(row.salary)}</td>
                <td>${fmtMoney(row.matchAmt)} <span class="sub-text">(${row.matchPct}%)</span></td>
                <td>${row.ytdBonus > 0 ? fmtMoney(row.ytdBonus) : '-'} <span class="sub-text">(YTD)</span></td>
                <td>${row.ytdEdu > 0 ? fmtMoney(row.ytdEdu) : '-'} <span class="sub-text">(YTD)</span></td>
                <td style="font-weight:bold; color:var(--accent)">${fmtMoney(row.totalComp)}</td>
            `;
            tbody.appendChild(tr);
        });

        const labels = data.map(d => {
            const dt = new Date(d.date);
            return dt.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
        });

        // REFINED COLORS: Blue, Green, Purple, Yellow
        const cSalary = palette[0];
        const cMatch = palette[2];
        const cEdu = palette[1];
        const cBonus = palette[4];

        if (charts.salaryTrend) charts.salaryTrend.destroy();
        charts.salaryTrend = new Chart(document.getElementById('salaryTrendChart'), {
            type: 'bar',
            plugins: [ChartDataLabels],
            data: {
                labels: labels,
                datasets: [
                    { 
                        label: 'Base Salary', data: data.map(d => d.salary), 
                        backgroundColor: cSalary + '88', borderColor: cSalary, borderWidth: 1, stack: 'Stack 0' 
                    }, 
                    { 
                        label: 'Company Match', data: data.map(d => d.matchAmt), 
                        backgroundColor: cMatch + '88', borderColor: cMatch, borderWidth: 1, stack: 'Stack 0' 
                    },
                    { 
                        label: 'Education (YTD)', data: data.map(d => d.ytdEdu), 
                        backgroundColor: cEdu + '88', borderColor: cEdu, borderWidth: 1, stack: 'Stack 0' 
                    },
                    { 
                        label: 'Bonus (YTD)', data: data.map(d => d.ytdBonus), 
                        backgroundColor: cBonus + '88', borderColor: cBonus, borderWidth: 1, stack: 'Stack 0' 
                    }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'top' },
                    datalabels: {
                        color: '#000000', 
                        font: { weight: 'bold', size: isMobile ? 6 : 8 }, 
                        formatter: (val) => val > 500 ? fmtMoneySimple(val) : ''
                    }
                },
                scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } }
            }
        });

        if (charts.compBreakdown) charts.compBreakdown.destroy();
        charts.compBreakdown = new Chart(document.getElementById('compBreakdownChart'), {
            type: 'doughnut',
            plugins: [ChartDataLabels],
            data: {
                labels: ['Base Salary', 'Match', 'Education (YTD)', 'Bonus (YTD)'],
                datasets: [{
                    data: [latest.salary, latest.matchAmt, latest.ytdEdu, latest.ytdBonus],
                    backgroundColor: [cSalary + '88', cMatch + '88', cEdu + '88', cBonus + '88'],
                    borderColor: [cSalary, cMatch, cEdu, cBonus],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'right' },
                    datalabels: {
                        color: '#000000', 
                        font: { weight: 'bold', size: isMobile ? 9 : 12 }, textAlign: 'center',
                        formatter: (val, ctx) => {
                            let sum = ctx.dataset.data.reduce((a, b) => a + b, 0);
                            let pct = ((val*100) / sum).toFixed(1) + "%";
                            return val > 0 ? fmtMoneySimple(val) + '\n(' + pct + ')' : '';
                        }
                    }
                }
            }
        });
    }

    // ==========================================
    // LOGIC: PROJECTION
    // ==========================================
    
    function updateAllProjections() {
        updateExtrapolationCards();
        updateProjectionTable();
    }

    function updateProjectionTable() {
        const rate = parseFloat(document.querySelector('input[name="extrapolationRate"]:checked').value);
        const data = projectionDataStore[rate];
        const tbody = document.getElementById('projectionTableBody');
        tbody.innerHTML = '';

        if (!data) return;

        data.forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td style="font-weight:bold">${row.year}</td>
                <td style="color:#7f8c8d">${fmtMoney(row.startBal)}</td>
                <td style="color:#2980b9; font-weight:500;">
                    ${fmtMoney(row.annualContrib)}
                </td>
                <td style="color:#27ae60;">
                    +${fmtMoney(row.annualGrowth)}
                </td>
                <td style="font-weight:bold; color:var(--text); background:rgba(0,0,0,0.05);">
                    ${fmtMoney(row.endBal)}
                </td>
            `;
            tbody.appendChild(tr);
        });
    }

    function updateExtrapolationCards() {
        const rate = parseFloat(document.querySelector('input[name="extrapolationRate"]:checked').value);
        const meta = projectionMetadata[rate];

        if (!meta) return;

        document.getElementById('card-nw-label').innerText = `Projected Net Worth (${(rate*100).toFixed(1)}%)`;
        document.getElementById('proj-nw-card').innerHTML = `<div>${fmtMoneySimple(meta.finalLiquid)} <span style="font-size:0.6em; color:#7f8c8d">Liquid</span></div><div style="font-size:0.8em; margin-top:4px; color:var(--text)">${fmtMoneySimple(meta.totalNW)} <span style="font-size:0.8em; color:#7f8c8d">Total</span></div>`;
        
        document.getElementById('proj-porsche-date').innerText = meta.porscheDate ? meta.porscheDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }) : "Not Reached";
        document.getElementById('proj-porsche-countdown').innerText = formatCountdown(meta.porscheDate);
        document.getElementById('proj-porsche-sub').innerText = `Estimated Date (${(rate*100).toFixed(1)}% Rtn)`;

        document.getElementById('proj-house-date').innerText = meta.houseDate ? meta.houseDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }) : "Not Reached";
        document.getElementById('proj-house-countdown').innerText = formatCountdown(meta.houseDate);
        document.getElementById('proj-house-sub').innerText = `Estimated Date (${(rate*100).toFixed(1)}% Rtn)`;
    }

    function renderProjectionChart(startBalance, startInflow, startDateStr, isSilent = false) {
        const rates = [0.05, 0.075, 0.10, 0.125, 0.15];
        projectionDataStore = {};
        projectionMetadata = {};

        const currentYear = new Date().getFullYear();
        const endYear = currentYear + 25;
        
        // Parsing dates
        const parts = startDateStr.split('-');
        let currentDate = new Date(parseInt(parts[0]), parseInt(parts[1])-1, 1);
        
        // PAYDAY ANCHOR SETUP
        const anchorInput = document.getElementById('paydayAnchor');
        const anchorParts = anchorInput.value.split('-'); // Parse YYYY-MM-DD
        
        // --- SMART BASE PAYCHECK CALCULATION ---
        // 1. Determine "Previous Month" relative to the Current Data Point
        // If data is up to May 2025 (currentDate), inflow comes from April 2025.
        // We need to know how many paydays were in April 2025 to normalize the inflow.
        let baselineMonthDate = new Date(currentDate);
        baselineMonthDate.setMonth(baselineMonthDate.getMonth() - 1); 
        
        // 2. Count Paydays in that specific baseline month
        let blStart = new Date(baselineMonthDate.getFullYear(), baselineMonthDate.getMonth(), 1);
        let blEnd = new Date(baselineMonthDate.getFullYear(), baselineMonthDate.getMonth() + 1, 0);
        let blTracker = new Date(parseInt(anchorParts[0]), parseInt(anchorParts[1])-1, parseInt(anchorParts[2]));
        
        // Align tracker to before range
        while(blTracker > blStart) { blTracker.setDate(blTracker.getDate() - 14); }
        // Walk forward
        let paychecksInBaseline = 0;
        while(blTracker < blStart) { blTracker.setDate(blTracker.getDate() + 14); }
        // Now blTracker is >= blStart. Count within range.
        while(blTracker <= blEnd) {
            paychecksInBaseline++;
            blTracker.setDate(blTracker.getDate() + 14);
        }
        
        // 3. Fallback if 0 (shouldn't happen with valid logic, but safety first)
        if(paychecksInBaseline < 2) paychecksInBaseline = 2; 
        
        // 4. Derive Base Paycheck Amount
        let paycheckAmount = startInflow / paychecksInBaseline;
        // ----------------------------------------

        const labels = [];
        const timeline = [];
        
        let tempDate = new Date(currentDate);
        while (tempDate.getFullYear() < endYear || (tempDate.getFullYear() === endYear && tempDate.getMonth() <= 11)) {
            timeline.push(new Date(tempDate));
            labels.push(tempDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }));
            tempDate.setMonth(tempDate.getMonth() + 1);
        }

        const datasets = [];
        const projColors = [palette[0], palette[1], palette[2], palette[3], palette[4]];
        
        const annotations = {
            porscheLine: {
                type: 'line', yMin: 3, yMax: 3, borderColor: '#F39C12', borderWidth: 4, borderDash: [6, 4],
                label: { 
                    display: true, content: 'Porsche 911 (-$300k)', position: 'start', 
                    backgroundColor: 'rgba(243, 156, 18, 0.9)', color: 'white',
                    font: { size: isMobile ? 8 : 10, weight: 'bold' },  
                    yAdjust: -15, 
                    xAdjust: 10 
                }
            },
            houseLine: {
                type: 'line', yMin: 10, yMax: 10, borderColor: '#16A085', borderWidth: 4, borderDash: [6, 4],
                label: { 
                    display: true, content: 'Beach House (-$5M)', position: 'start', 
                    backgroundColor: 'rgba(22, 160, 133, 0.9)', color: 'white',
                    font: { size: isMobile ? 8 : 10, weight: 'bold' }, 
                    yAdjust: -15, 
                    xAdjust: 10 
                }
            }
        };

        rates.forEach((rate, idx) => {
            let balance = startBalance;
            let currentPaycheck = paycheckAmount; 
            
            // Independent Tracker for Paydays for this Rate simulation
            let payTracker = new Date(parseInt(anchorParts[0]), parseInt(anchorParts[1])-1, parseInt(anchorParts[2]));

            // Pre-roll tracker to start of timeline
            while(payTracker < timeline[0]) {
                 payTracker.setDate(payTracker.getDate() + 14);
            }

            let porscheBought = false, houseBought = false;
            let currentYearStats = { year: timeline[0].getFullYear(), startBal: balance, annualContrib: 0, annualGrowth: 0 };
            let yearlyData = [];
            
            let porscheDate = null;
            let houseDate = null;

            const dataPoints = timeline.map((date, i) => {
                const year = date.getFullYear();
                if (year !== currentYearStats.year) {
                    currentYearStats.endBal = balance;
                    currentYearStats.annualGrowth = currentYearStats.endBal - currentYearStats.startBal - currentYearStats.annualContrib;
                    yearlyData.push({ ...currentYearStats });
                    currentYearStats = { year: year, startBal: balance, annualContrib: 0, annualGrowth: 0 };
                }

                if (i > 0) { 
                    // Apply raises to base paycheck amount using Auto-Calculated Globals
                    if (date.getMonth() === 0) currentPaycheck *= (1 + globalJanRaise);
                    if (date.getMonth() === 6) currentPaycheck *= (1 + globalJulyRaise);
                }

                // Determine Paychecks in this specific month
                let paychecksInMonth = 0;
                const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                
                while (payTracker <= monthEnd) {
                    if (payTracker >= monthStart) {
                        paychecksInMonth++;
                    }
                    payTracker.setDate(payTracker.getDate() + 14);
                }

                const monthlyContrib = currentPaycheck * paychecksInMonth;

                const growth = balance * (rate / 12);
                balance += growth;
                balance += monthlyContrib;
                currentYearStats.annualContrib += monthlyContrib;

                if (balance >= 3000000 && !porscheBought) {
                    balance -= 300000; porscheBought = true;
                    porscheDate = date;
                    annotations[`porsche_${idx}`] = { type: 'label', xValue: labels[i], yValue: 3, content: [`${year}`, `${(rate*100).toFixed(1)}%`], position: 'center', color: projColors[idx], font: { weight: 'bold', size: isMobile ? 6 : 8 }, yAdjust: -40 };
                }
                if (balance >= 10000000 && !houseBought) {
                    balance -= 5000000; houseBought = true;
                    houseDate = date;
                    annotations[`house_${idx}`] = { type: 'label', xValue: labels[i], yValue: 10, content: [`${year}`, `${(rate*100).toFixed(1)}%`], position: 'center', color: projColors[idx], font: { weight: 'bold', size: isMobile ? 6 : 8 }, yAdjust: -40 };
                }
                return balance / 1000000; 
            });

            currentYearStats.endBal = balance;
            currentYearStats.annualGrowth = currentYearStats.endBal - currentYearStats.startBal - currentYearStats.annualContrib;
            yearlyData.push({ ...currentYearStats });
            
            projectionDataStore[rate] = yearlyData;

            let finalBalance = balance;
            let assetValue = 0;
            if (porscheBought) assetValue += 300000;
            if (houseBought) assetValue += 5000000;
            let totalNW = finalBalance + assetValue;

            projectionMetadata[rate] = {
                finalLiquid: finalBalance,
                totalNW: totalNW,
                porscheDate: porscheDate,
                houseDate: houseDate
            };

            datasets.push({ label: (rate * 100).toFixed(1) + '%', data: dataPoints, borderColor: projColors[idx], backgroundColor: projColors[idx], borderWidth: 2, pointRadius: 0, tension: 0.4 });
        });

        // Initial Update
        updateAllProjections();

        if (charts.projection) charts.projection.destroy();
        charts.projection = new Chart(document.getElementById('projectionChart'), {
            type: 'line', data: { labels: labels, datasets: datasets },
            options: {
                animation: isSilent ? false : {}, 
                responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                plugins: { legend: { display: true, position: 'top' }, tooltip: { callbacks: { label: (ctx) => ctx.dataset.label + ': $' + ctx.raw.toFixed(2) + 'M' } }, annotation: { annotations: annotations } },
                scales: { 
                    y: { 
                        title: { display: true, text: 'Net Worth ($ Millions)' }, 
                        ticks: { callback: (val) => '$' + val + 'M', font: { size: isMobile ? 6 : 10 } } 
                    }, 
                    x: { 
                        title: { display: true, text: 'Year', font: {weight:'bold'} }, 
                        ticks: { maxTicksLimit: 20, font: { size: isMobile ? 6 : 10 }, callback: function(val) { const label = this.getLabelForValue(val); if (label.includes('Jan')) return label.split(' ')[1]; return null; } } 
                    } 
                }
            }
        });
    }

    // ==========================================
    // LOGIC: INVESTMENTS PARSING
    // ==========================================
    function parseSheetData(rows) {
        if (!rows) return [];
        const data = [];
        for (let i = 1; i < rows.length; i++) {
            const cols = rows[i];
            if (cols.length > 8) {
                const dateStr = cols[0];
                const deposits = cleanMoney(cols[2]);
                const withdrawals = cleanMoney(cols[3]); 
                const marketGain = cleanMoney(cols[4]);
                const income = cleanMoney(cols[5]);
                const cumulative = cleanMoney(cols[7]);
                const balance = cleanMoney(cols[8]);
                const invested = cols[9] ? cols[9].trim() : "Unknown";

                const dateParts = dateStr.split('/');
                if(dateParts.length < 2) continue;
                
                let month = dateParts[0].padStart(2, '0');
                let year = dateParts[2];
                // Net transfers for main chart
                const netTransfers = deposits + withdrawals;

                data.push({
                    key: `${year}-${month}`,
                    dateObj: new Date(year, month - 1, 1),
                    deposits: netTransfers,
                    rawDeposits: deposits, 
                    rawWithdrawals: withdrawals,
                    marketGain: marketGain,
                    income: income,
                    cumulative: cumulative,
                    balance: balance,
                    invested: invested
                });
            }
        }
        
        data.sort((a, b) => a.dateObj - b.dateObj);
        return data;
    }

    async function initDashboard() {
        try {
            document.getElementById('loading').innerHTML = "Loading Sheet Data...";
            const response = await fetch(API_URL);
            const rawData = await response.json();

            // 1. Salary
            if (rawData.salary) {
                processSalaryData(rawData.salary);
            }

            // 2. Investments - Cleaned Names
            const accounts = [
                { id: 'wellsFargo', name: 'Wells Fargo', data: parseSheetData(rawData.wellsFargo) },
                { id: 'fidelity', name: 'Fidelity', data: parseSheetData(rawData.fidelity) },
                { id: 'boeing', name: 'Boeing', data: parseSheetData(rawData.boeing) },
                { id: 'vanguardA', name: 'Vanguard Plan A', data: parseSheetData(rawData.vanguardA) },
                { id: 'vanguardB', name: 'Vanguard Plan B', data: parseSheetData(rawData.vanguardB) },
                { id: 'vanguardUTMA', name: 'Vanguard UTMA', data: parseSheetData(rawData.vanguardUTMA) }
            ];
            
            globalAccountsData = accounts;

            // 3. APPLY REAL-TIME MARKET DATA (Initial)
            await updateWithLiveMarketData(accounts, false);

            processAndRender(accounts, false);
            
            // Hide loading
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 300);

            // 4. START AUTO-REFRESH (Every 60 Seconds)
            startAutoRefresh();

        } catch (error) {
            console.error(error);
            document.getElementById('loading').innerHTML = "Error loading data.<br>" + error.message;
        }
    }

    function startAutoRefresh() {
        // Update timer text every second
        setInterval(() => {
            refreshTimer--;
            if (refreshTimer <= 0) refreshTimer = 60;
            document.getElementById('refresh-timer').innerText = `Updates in ${refreshTimer}s`;
        }, 1000);

        // Actual Refresh Loop (60s)
        setInterval(async () => {
            console.log("Refreshing Market Data...");
            await updateWithLiveMarketData(globalAccountsData, true); // Silent = true
            processAndRender(globalAccountsData, true); // Silent render
            refreshTimer = 60;
        }, 60000);
    }

    function createSnapshotTable(accounts, alignedData, index, tableId) {
        const body = document.getElementById(tableId);
        body.innerHTML = '';
        
        if (index < 0) {
            body.innerHTML = '<tr><td colspan="7" style="text-align:center">No Data Available for this period</td></tr>';
            return;
        }

        accounts.forEach(acc => {
            const entry = alignedData[acc.id][index];
            if (entry.balance < 0.01) return;

            const tr = document.createElement('tr');
            if(entry.isLive) {
                // If live, standard mode uses light yellow, scifi mode needs to handle it via CSS or JS
                tr.style.backgroundColor = isSciFiMode ? 'rgba(255, 255, 0, 0.05)' : "#fef9e7"; 
            }

            const totalNetDep = entry.balance - entry.cumulative;
            let roiPct = 0;
            if (totalNetDep !== 0) { roiPct = (entry.cumulative / totalNetDep) * 100; }
            const roiColor = roiPct >= 0 ? 'text-green' : 'text-red';
            const roiText = (roiPct >= 0 ? '+' : '') + roiPct.toFixed(1) + '%';
            
            const liveTag = entry.isLive ? '<span style="background:red; color:white; font-size:9px; padding:1px 3px; border-radius:3px; margin-left:5px; vertical-align:middle;">LIVE</span>' : '';
            
            // Error handling display
            let marketGainDisplay = "";
            if (entry.isError) {
                marketGainDisplay = '<span style="color:#e74c3c; font-style:italic; font-size:0.9em;">Unavailable</span>';
            } else {
                 const isZero = (entry.marketGain === 0);
                 const gainClass = entry.marketGain >= 0 ? 'text-green' : 'text-red';
                 let warning = "";
                 // If it is VIGIX/VTSAX on the Live row, always show (Daily) tag
                 if(entry.isLive && (entry.invested.includes('VIGIX') || entry.invested.includes('VTSAX'))) {
                     warning = ' <span style="color:#f39c12; font-size:0.7em;">(Daily)</span>';
                 }
                 marketGainDisplay = `<span class="${gainClass}">${entry.marketGain >= 0 ? '+' : ''}${fmtMoney(entry.marketGain + entry.income)}</span>${warning}`;
            }

            tr.innerHTML = `
                <td>
                    <span class="account-name">${acc.name}${liveTag}</span>
                    <span class="ticker-tag">${entry.invested}</span>
                </td>
                <td style="font-weight:bold">${fmtMoney(entry.balance)}</td>
                <td>
                    ${marketGainDisplay}
                </td>
                <td>
                    ${fmtMoney(entry.deposits + entry.income)}
                </td>
                <td>${fmtMoney(totalNetDep)}</td>
                <td style="font-weight:bold" class="${entry.cumulative >= 0 ? 'text-green' : 'text-red'}">
                    ${fmtMoney(entry.cumulative)}
                </td>
                <td style="font-weight:bold" class="${roiColor}">${roiText}</td>
            `;
            body.appendChild(tr);
        });
    }

    function renderWellsFargoWidget(accounts, isSilent = false) {
        const wf = accounts.find(a => a.id === 'wellsFargo');
        if (!wf) return;
        
        const relevantData = wf.data.filter(d => !d.isLive).slice(-24);
        
        const labels = relevantData.map(d => d.key);
        const values = relevantData.map(d => Math.abs(d.rawWithdrawals)); 
        
        // Consistent Red
        const cRed = palette[5];

        if (charts.wfWithdrawal) charts.wfWithdrawal.destroy();
        charts.wfWithdrawal = new Chart(document.getElementById('wfWithdrawalChart'), {
            type: 'bar',
            plugins: [ChartDataLabels],
            data: {
                labels: labels,
                datasets: [{
                    label: 'Monthly Withdrawals',
                    data: values,
                    backgroundColor: cRed + '88', // alpha
                    borderColor: cRed,
                    borderWidth: 1,
                    borderRadius: 2,
                    barPercentage: 1.0, 
                    categoryPercentage: 1.0 
                }]
            },
            options: {
                animation: isSilent ? false : {}, // Disable animation if silent update
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    datalabels: {
                        color: '#2c3e50',
                        anchor: isMobile ? 'end' : 'end', // Anchor top for both
                        align: isMobile ? 'top' : 'end', // Top (vertical) or Right (horizontal)
                        rotation: isMobile ? -90 : 0,    // Rotate only on mobile
                        font: { weight: 'bold', size: 9 },
                        formatter: (val) => val > 200 ? fmtMoneySimple(val) : '' 
                    }
                },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#f0f0f0' }, ticks: { font: { size: 9 } } },
                    x: { grid: { display: false }, ticks: { font: { size: 8 }, maxRotation: 90, minRotation: 90 } }
                }
            }
        });
    }

    function initIncomeAnalysis(accounts) {
        const container = document.getElementById('income-filter-container');
        
        if (container.children.length > 1) return; // Prevent duplicates

        // Define Defaults: Wells, UTMA, Plan A, Plan B
        const defaultIds = ['wellsFargo', 'vanguardUTMA', 'vanguardA', 'vanguardB'];

        // Create Checkboxes
        accounts.forEach(acc => {
            const label = document.createElement('label');
            label.className = 'checkbox-item';
            const isChecked = defaultIds.includes(acc.id) ? 'checked' : '';
            label.innerHTML = `<input type="checkbox" value="${acc.id}" ${isChecked} onchange="updateIncomeAnalysis()"> ${acc.name}`;
            container.appendChild(label);
        });

        updateIncomeAnalysis(false); // Initial load has animation
    }

    function updateIncomeAnalysis(isSilent = false) {
        const checkboxes = document.querySelectorAll('#income-filter-container input[type="checkbox"]');
        const selectedIds = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);

        const targetAccounts = globalAccountsData.filter(a => selectedIds.includes(a.id));
        
        // Align Data by Month
        const allMonths = new Set();
        globalAccountsData.forEach(acc => acc.data.forEach(d => { if(!d.isLive) allMonths.add(d.key); }));
        const sortedMonths = Array.from(allMonths).sort().slice(-24); // Last 24 months

        const incomeData = sortedMonths.map(month => {
            let sum = 0;
            targetAccounts.forEach(acc => {
                const entry = acc.data.find(d => d.key === month);
                if (entry) sum += entry.rawDeposits;
            });
            return sum;
        });

        // Update Trailing 12
        const last12Data = incomeData.slice(-12);
        const trailing12Sum = last12Data.reduce((a,b) => a+b, 0);
        document.getElementById('stat-12mo-income').innerText = fmtMoneySimple(trailing12Sum);

        // Render Chart - Use Green from Palette
        const cGreen = palette[2];

        if(charts.incomeTrend) charts.incomeTrend.destroy();

        charts.incomeTrend = new Chart(document.getElementById('incomeTrendChart'), {
            type: 'bar',
            plugins: [ChartDataLabels],
            data: {
                labels: sortedMonths,
                datasets: [{
                    label: 'Total After-Tax Deposits',
                    data: incomeData,
                    backgroundColor: cGreen + '88',
                    borderColor: cGreen,
                    borderWidth: 1,
                    borderRadius: 3,
                    barPercentage: 1.0, 
                    categoryPercentage: 1.0 
                }]
            },
            options: {
                animation: isSilent ? false : {}, // Disable animation if silent update
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    datalabels: {
                        color: '#2c3e50',
                        anchor: isMobile ? 'end' : 'end', // Matches WF Chart
                        align: isMobile ? 'top' : 'end', 
                        rotation: isMobile ? -90 : 0,    
                        font: { weight: 'bold', size: 9 },
                        formatter: (val) => val > 500 ? fmtMoneySimple(val) : ''
                    }
                },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#f0f0f0' }, ticks: { font: { size: 9 } } },
                    x: { grid: { display: false }, ticks: { font: { size: 8 }, maxRotation: 90, minRotation: 90 } }
                }
            }
        });
    }

    function processAndRender(accounts, isSilent = false) {
        const allMonths = new Set();
        accounts.forEach(acc => acc.data.forEach(d => allMonths.add(d.key)));
        const sortedMonths = Array.from(allMonths).sort();

        const alignedData = {};
        const globalTotals = { balance: [], gainLoss: [], income: [], deposits: [], cumulative: [] };
        
        accounts.forEach(acc => alignedData[acc.id] = []);

        sortedMonths.forEach(monthKey => {
            let monthBalance = 0, monthGain = 0, monthIncome = 0, monthDeposits = 0, monthCumulative = 0;

            accounts.forEach(acc => {
                const entry = acc.data.find(d => d.key === monthKey);
                if (entry) {
                    alignedData[acc.id].push(entry);
                    monthBalance += entry.balance;
                    monthGain += entry.marketGain + entry.income; 
                    monthIncome += entry.income;
                    monthDeposits += entry.deposits;
                    monthCumulative += entry.cumulative;
                } else {
                    alignedData[acc.id].push({ balance: 0, marketGain: 0, income: 0, deposits: 0, cumulative: 0, invested: '-', rawWithdrawals: 0 });
                }
            });

            globalTotals.balance.push(monthBalance);
            globalTotals.gainLoss.push(monthGain);
            globalTotals.income.push(monthIncome);
            globalTotals.deposits.push(monthDeposits);
            globalTotals.cumulative.push(monthCumulative);
        });

        const lastIndex = sortedMonths.length - 1;
        
        // Update Live Header with Time
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        document.getElementById('latest-date-display').innerHTML = `<span class="live-dot"></span>Data as of ${sortedMonths[lastIndex]} (${timeString})`;
        document.getElementById('latest-date-display').style.color = "#c0392b"; 
        
        document.getElementById('stat-networth').innerText = fmtMoney(globalTotals.balance[lastIndex]);
        
        const totalGain = globalTotals.cumulative[lastIndex];
        const gainEl = document.getElementById('stat-lifetime-gain');
        gainEl.innerText = (totalGain >= 0 ? '+' : '') + fmtMoney(totalGain);
        gainEl.className = 'stat-value ' + (totalGain >= 0 ? 'text-green' : 'text-red');

        const monthlyPL = globalTotals.gainLoss[lastIndex];
        const plEl = document.getElementById('stat-monthly-pl');
        plEl.innerText = (monthlyPL >= 0 ? '+' : '') + fmtMoney(monthlyPL);
        plEl.className = 'stat-value ' + (monthlyPL >= 0 ? 'text-green' : 'text-red');

        const lastIncome = globalTotals.income[lastIndex];
        const lastDeposits = globalTotals.deposits[lastIndex];
        const totalInflow = lastIncome + lastDeposits;
        
        document.getElementById('stat-monthly-inflow').innerText = fmtMoney(totalInflow);
        document.getElementById('stat-monthly-inflow-sub').innerHTML = `Income: ${fmtMoney(lastIncome)} <span style="margin:0 4px; color:#ccc">|</span> Net Dep: ${fmtMoney(lastDeposits)}`;

        let projectionInflow = totalInflow; 
        if (lastIndex > 0) projectionInflow = globalTotals.income[lastIndex - 1] + globalTotals.deposits[lastIndex - 1];
        
        renderProjectionChart(globalTotals.balance[lastIndex], projectionInflow, sortedMonths[lastIndex], isSilent);

        const stackedDatasets = accounts.map((acc, index) => {
            const color = palette[index % palette.length];
            return {
                label: acc.name,
                data: alignedData[acc.id].map(d => d.balance),
                backgroundColor: color + '88', borderColor: color, borderWidth: 1, fill: true, tension: 0.2
            };
        });
        
        // RENDER TABLES (Live and Previous)
        createSnapshotTable(accounts, alignedData, lastIndex, 'snapshotBody');
        createSnapshotTable(accounts, alignedData, lastIndex - 1, 'prevSnapshotBody');
        
        // RENDER WF WIDGET
        renderWellsFargoWidget(accounts, isSilent);

        // INITIALIZE INCOME ANALYSIS (New)
        initIncomeAnalysis(accounts);
        // Explicitly update chart for refresh cycles (init only runs once)
        updateIncomeAnalysis(isSilent);

        // CHARTS
        const allocation = {};
        accounts.forEach(acc => {
            const latest = alignedData[acc.id][lastIndex];
            if (latest.balance > 0) {
                const ticker = latest.invested;
                allocation[ticker] = (allocation[ticker] || 0) + latest.balance;
            }
        });
        const allocLabels = Object.keys(allocation);
        const allocValues = Object.values(allocation);
        const totalPortfolio = allocValues.reduce((a, b) => a + b, 0);

        // Allocation Donut - Uses standard Palette
        if (charts.allocation) charts.allocation.destroy();
        charts.allocation = new Chart(document.getElementById('allocationChart'), {
            type: 'doughnut', plugins: [ChartDataLabels],
            data: { 
                labels: allocLabels, 
                datasets: [{ 
                    data: allocValues, 
                    backgroundColor: palette.map(c => c + '88'), // alpha background
                    borderColor: palette, // solid border
                    borderWidth: 1
                }] 
            },
            options: { 
                animation: isSilent ? false : {}, // Disable animation if silent update
                maintainAspectRatio: false, layout: { padding: 80 }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => ctx.label + ': ' + fmtMoney(ctx.raw) + ' (' + ((ctx.raw/totalPortfolio)*100).toFixed(1) + '%)' } }, datalabels: { color: '#2c3e50', anchor: 'end', align: 'end', offset: 10, formatter: (val, ctx) => (val/totalPortfolio > 0.01) ? ctx.chart.data.labels[ctx.dataIndex] + '\n' + fmtMoneySimple(val) : '' } } }
        });

        if (charts.balance) charts.balance.destroy();
        charts.balance = new Chart(document.getElementById('balanceChart'), {
            type: 'line', plugins: [ChartDataLabels],
            data: { labels: sortedMonths, datasets: stackedDatasets },
            options: {
                animation: isSilent ? false : {}, // Disable animation if silent update
                responsive: true, maintainAspectRatio: false, layout: { padding: { right: isMobile ? 90 : 150 } }, interaction: { mode: 'index', intersect: false },
                plugins: { legend: { align: isMobile ? 'start' : 'center', position: 'top', labels: { boxWidth: isMobile ? 12 : 40, padding: 10 } }, datalabels: { align: 'right', anchor: 'end', offset: 5, backgroundColor: 'white', borderColor: (ctx) => ctx.dataset.borderColor, borderWidth: 1, borderRadius: 4, padding: isMobile ? 4 : 6, color: 'black', font: { weight: 'bold', size: isMobile ? 9 : 10 }, formatter: (val, ctx) => (ctx.dataIndex === ctx.dataset.data.length - 1 && val > 500) ? ctx.dataset.label + '\n' + fmtMoneySimple(val) : null, display: (ctx) => ctx.dataIndex === ctx.dataset.data.length - 1 } },
                scales: { y: { beginAtZero: true, stacked: true } }
            }
        });

        // P&L Chart - Uses Green/Red from Palette with styling
        const cGreen = palette[2];
        const cRed = palette[5];

        if (charts.pl) charts.pl.destroy();
        charts.pl = new Chart(document.getElementById('plChart'), {
            type: 'bar',
            data: { 
                labels: sortedMonths, 
                datasets: [{ 
                    label: 'Monthly Net Gain/Loss', 
                    data: globalTotals.gainLoss, 
                    backgroundColor: globalTotals.gainLoss.map(v => v >= 0 ? cGreen + '88' : cRed + '88'),
                    borderColor: globalTotals.gainLoss.map(v => v >= 0 ? cGreen : cRed),
                    borderWidth: 1
                }] 
            },
            options: { 
                animation: isSilent ? false : {}, // Disable animation if silent update
                responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { grid: { color: '#f0f0f0' } }, x: { grid: { display: false } } } 
            }
        });

        const historyHeader = document.getElementById('historyHeader');
        historyHeader.innerHTML = '<th>Month</th><th>Total Balance</th><th>Total Gain/Loss</th>';
        accounts.forEach(acc => {
            const th = document.createElement('th');
            th.innerText = acc.name.split(' ')[0]; th.style.fontSize = "0.8em"; historyHeader.appendChild(th);
        });

        const historyBody = document.getElementById('historyBody');
        historyBody.innerHTML = '';
        for (let i = sortedMonths.length - 1; i >= 0; i--) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${sortedMonths[i]}</td><td style="font-weight:bold">${fmtMoney(globalTotals.balance[i])}</td><td class="${globalTotals.gainLoss[i] >= 0 ? 'text-green' : 'text-red'}">${globalTotals.gainLoss[i] >= 0 ? '+' : ''}${fmtMoney(globalTotals.gainLoss[i])}</td>`;
            accounts.forEach(acc => {
                const val = alignedData[acc.id][i].balance;
                const td = document.createElement('td');
                td.innerText = val ? fmtMoney(val) : '-'; td.style.fontSize = "0.85em"; tr.appendChild(td);
            });
            historyBody.appendChild(tr);
        }
        
        // Ensure charts respect current theme (important for initial load/refresh)
        updateChartStyles();
    }

    // --- TRADINGVIEW WIDGET (Dynamic) ---
    function initTradingView(theme) {
        document.getElementById('tv-widget-container').innerHTML = ''; // Clear existing
        new TradingView.widget({
            "container_id": "tv-widget-container",
            "autosize": true,
            "symbol": "NASDAQ:GOOGL",
            "interval": "D",
            "timezone": "America/New_York",
            "theme": theme,
            "style": "1",
            "locale": "en",
            "toolbar_bg": "#f1f3f6",
            "enable_publishing": false,
            "allow_symbol_change": true,
            "save_image": false,
            "details": true,     // Ensure this is true
            "hotlist": true,     // Enable this (was false)
            "calendar": true,    // Enable this (was false)
            "show_popup_button": true,
            "popup_width": "1000",
            "popup_height": "650",
            "watchlist": ["NASDAQ:GOOGL", "NASDAQ:VIGIX", "NASDAQ:VTSAX", "NASDAQ:BND", "AMEX:BIL"]
        });
    }

    initDashboard();
    initTradingView('dark'); // Changed default to dark

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Investment & Income Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.1.0/chartjs-plugin-annotation.min.js"></script>
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* FIX: Global Box Sizing */
        * { box-sizing: border-box; }

        /* =========================================
           GLOBAL VARIABLES
           ========================================= */
        :root {
            /* Colors */
            --primary: #2c3e50;
            --success: #27ae60;
            --danger: #c0392b;
            --bg: #ecf0f1;
            --card-bg: rgba(255, 255, 255, 0.9);
            --text: #2c3e50;
            --accent: #8e44ad;
            --goal: #e67e22;
            --border-color: rgba(0,0,0,0.1);
            --crosshair-color: rgba(0,0,0,0.2);
            --th-bg: rgba(0,0,0,0.03);
            --hover-bg: rgba(0,0,0,0.02);
            
            /* Slider Colors (Light Mode) */
            --slider-connect: #2c3e50;
            --slider-bg: #dcdcdc;
            --slider-handle-bg: #fff;
            --slider-tooltip: transparent;
            --slider-tooltip-text: #2c3e50;

            /* Fonts & Structure */
            --font-main: 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        
        /* =========================================
           SCI-FI / DARK MODE OVERRIDES
           ========================================= */
        body.sci-fi-mode {
            --primary: #bdc3c7;
            --success: #00ff88; /* Neon Green */
            --danger: #ff4757;  /* Neon Red */
            --bg: #050505;      /* Deep Space Black */
            --card-bg: rgba(20, 20, 20, 0.65); /* Glassy Dark */
            --text: #ecf0f1;
            --accent: #a29bfe;
            --goal: #fab1a0;
            --border-color: rgba(255,255,255,0.15);
            --crosshair-color: rgba(255,255,255,0.2);
            --th-bg: rgba(255,255,255,0.1);
            --hover-bg: rgba(255,255,255,0.05);

            /* Slider Dark Mode */
            --slider-connect: rgba(52, 152, 219, 0.4); /* Transparent Neon Blue */
            --slider-bg: #222;
            --slider-handle-bg: #1a1a1a; 
            --slider-tooltip: transparent;
            --slider-tooltip-text: #95a5a6; 
        }

        /* Specific text color overrides */
        body.sci-fi-mode .text-green { color: #00ff88 !important; }
        body.sci-fi-mode .text-red { color: #ff4757 !important; }
        body.sci-fi-mode .text-purple { color: #a29bfe !important; }
        body.sci-fi-mode .account-name { color: #fff; }
        body.sci-fi-mode .sub-text { color: #95a5a6; }
        body.sci-fi-mode .ticker-tag { color: #3498db; border: 1px solid #3498db; }
        body.sci-fi-mode .daily-tag { color: #f1c40f; border: 1px solid #f1c40f; background: rgba(241, 196, 15, 0.1); }

        body.sci-fi-mode canvas {
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.1));
        }

        /* =========================================
           GLOBAL STRUCTURAL STYLES
           ========================================= */
        
        html, body { overflow-x: hidden; }

        body {
            font-family: var(--font-main);
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .container { max-width: 1600px; margin: 0 auto; width: 100%; transition: max-width 0.5s ease; }
        
        .card, .stat-card, header {
            border-radius: 0px; 
            border: 1px solid var(--border-color);
            box-shadow: none; 
            background: var(--card-bg);
            backdrop-filter: blur(10px); 
            position: relative;
        }

        .card::before {
            content: '+';
            position: absolute;
            top: 5px; right: 8px;
            color: var(--crosshair-color);
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
        }

        h1, h3, .section-header { text-transform: uppercase; letter-spacing: 2px; font-weight: 300; }
        h1 { margin: 0; font-size: 24px; color: var(--primary); line-height: 1.2; }
        
        .section-header {
            margin: 40px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
            color: var(--primary);
            font-size: 1.5em;
            display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;
        }

        /* =========================================
           COMPONENT STYLES
           ========================================= */

        .status-floater {
            position: absolute; right: 60px; background: var(--card-bg);
            padding: 10px 15px; border-radius: 0px; border: 1px solid var(--border-color);
            z-index: 998; backdrop-filter: blur(5px); text-align: right;
            display: flex; flex-direction: column; align-items: flex-end;
        }
        
        .status-floater.docked { position: fixed; top: 15px !important; }

        .refresh-btn {
            background: transparent; border: 1px solid var(--border-color); color: var(--text);
            cursor: pointer; padding: 2px 8px; font-size: 0.8em; text-transform: uppercase;
            letter-spacing: 1px; transition: all 0.2s; display: flex; align-items: center; gap: 5px;
        }
        .refresh-btn:hover { background: var(--primary); color: var(--bg); }

        .theme-toggle {
            position: fixed; top: 15px; right: 15px; width: 32px; height: 32px; 
            background: var(--primary); color: white; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; z-index: 999; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border: 2px solid white; transition: transform 0.2s;
        }
        .theme-toggle:hover { transform: scale(1.1); }
        .theme-toggle svg { width: 16px; height: 16px; fill: currentColor; }

        header {
            margin-bottom: 20px; padding: 20px; display: flex;
            flex-direction: row; justify-content: space-between; align-items: center; gap: 15px; flex-wrap: wrap;
        }

        header > div:first-child { width: auto; }
        #status-placeholder { width: 260px; height: 50px; pointer-events: none; flex-shrink: 0; }
        
        .subtitle { color: #7f8c8d; font-size: 0.9em; margin-top: 5px; letter-spacing: 0.5px; }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 15px; margin-bottom: 30px; }
        .stat-card { padding: 20px; min-width: 0; }
        
        .stat-label { font-size: 0.85em; color: #7f8c8d; text-transform: uppercase; letter-spacing: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .stat-value { font-size: 1.8em; font-weight: 700; color: var(--primary); margin-top: 5px; word-break: break-word; }
        .stat-sub { font-size: 0.85em; margin-top: 5px; color: #7f8c8d; }
        .text-green { color: var(--success); }
        .text-red { color: var(--danger); }
        .text-purple { color: var(--accent); }

        .card { padding: 20px; margin-bottom: 20px; width: 100%; min-width: 0; }
        .card h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1em; color: var(--text); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        
        .charts-row { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 30px; }
        .chart-container { position: relative; height: 350px; width: 100%; }
        .chart-container-tall { height: 480px; }
        .chart-container-small { height: 200px; } 

        #salary-trend-container { height: 420px; }

        .table-responsive { width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; }
        
        /* SCROLLABLE TABLE OVERRIDES FOR WATCHLIST */
        .watchlist-scroll-container {
            width: 100%; 
            overflow-x: auto;
            position: relative;
        }

        table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 0.9em; }
        
        th, td { 
            padding: 8px 10px; 
            text-align: right; 
            border-bottom: 1px solid var(--border-color); 
            white-space: nowrap;
            background-color: transparent;
        }
        
        /* Sticky Column Logic */
        .sticky-col {
            position: sticky;
            left: 0;
            z-index: 2;
            background-color: var(--card-bg); /* Opaque background to cover scrolling content */
            border-right: 1px solid var(--border-color);
        }
        .sticky-col-2 {
            position: sticky;
            left: 70px; /* Adjust based on approx width of first col */
            z-index: 2;
            background-color: var(--card-bg);
            border-right: 2px solid var(--border-color); /* Stronger separator */
        }
        
        /* Specific header backgrounds */
        th.sticky-col, th.sticky-col-2 {
            background-color: var(--th-bg); 
            z-index: 3; /* Headers on top of everything */
        }

        th:first-child, td:first-child { text-align: left; }
        th { background-color: var(--th-bg); color: var(--primary); text-transform: uppercase; font-size: 0.75em; letter-spacing: 1px; font-weight: 600; }
        tr:hover td { background-color: var(--hover-bg); }
        
        /* Highlight Vested Rows */
        @keyframes pulse-gold { 0% { border-color: #f1c40f; } 50% { border-color: #e67e22; } 100% { border-color: #f1c40f; } }
        
        tr.vested-row td {
            background-color: rgba(241, 196, 15, 0.08) !important;
            color: var(--text);
        }
        tr.vested-row td.sticky-col, tr.vested-row td.sticky-col-2 {
             background-color: var(--card-bg) !important; /* Keep sticky bg opaque but maybe add tint? */
             border-bottom: 1px solid rgba(241, 196, 15, 0.3);
        }
        /* Create a pseudo border for the whole row or just highlight text */
        tr.vested-row td:first-child {
            border-left: 3px solid #f1c40f;
        }

        .table-compact th, .table-compact td { padding: 5px 6px; font-size: 0.85em; }

        .ticker-tag { background: rgba(41, 128, 185, 0.1); color: #2980b9; padding: 2px 6px; border-radius: 4px; font-size: 0.85em; font-weight: 600; display: inline-block; }
        .daily-tag { background: rgba(243, 156, 18, 0.15); color: #d35400; padding: 1px 6px; border-radius: 4px; font-size: 0.75em; font-weight: 600; display: inline-block; margin-top: 4px; border: 1px solid rgba(243, 156, 18, 0.3); text-transform: uppercase; letter-spacing: 0.5px; }

        .status-dot { height: 6px; width: 6px; border-radius: 50%; display: inline-block; margin-right: 4px; vertical-align: middle; margin-bottom: 1px; }
        .status-pending { background-color: #f39c12; box-shadow: 0 0 3px #f39c12; }
        .status-updated { background-color: #27ae60; box-shadow: 0 0 3px #27ae60; }

        .account-name { font-weight: 500; display: block; }
        .sub-text { font-size: 0.75em; color: #999; display: block; margin-top: 2px; }
        
        .filter-group { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px; background: var(--hover-bg); padding: 10px; border-radius: 4px; border: 1px solid var(--border-color); }
        .filter-label { font-size: 0.85em; font-weight: bold; color: #7f8c8d; margin-right: 10px; align-self: center; }
        .checkbox-item { display: flex; align-items: center; font-size: 0.85em; cursor: pointer; color: var(--text); }
        .checkbox-item input { margin-right: 6px; }
        .radio-label { display: flex; align-items: center; cursor: pointer; color: var(--text); font-size: 0.85em; }
        .radio-label input { margin-right: 6px; cursor: pointer; }
        .radio-label:hover { color: var(--accent); }

        /* Watchlist specific */
        .watchlist-controls { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .watchlist-input { padding: 6px 10px; background: var(--bg); border: 1px solid var(--border-color); color: var(--text); border-radius: 4px; }
        .btn-small { padding: 6px 12px; font-size: 0.8em; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text); cursor: pointer; border-radius: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        .btn-small:hover { background: var(--primary); color: var(--bg); }
        .btn-active { background: var(--goal) !important; color: white !important; border-color: var(--goal) !important; }

        .watchlist-split { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .watchlist-col h4 { margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px; border-bottom: 2px solid; padding-bottom: 5px; }
        .watchlist-col.gainers h4 { color: var(--success); border-color: var(--success); }
        .watchlist-col.losers h4 { color: var(--danger); border-color: var(--danger); }

        /* =========================================
           SLIDER CUSTOMIZATION (UPDATED)
           ========================================= */
        .noUi-connect { background: var(--slider-connect); }
        body.sci-fi-mode .noUi-connect { box-shadow: 0 0 8px rgba(52, 152, 219, 0.3); border: 1px solid rgba(52, 152, 219, 0.4); }

        .noUi-target { background: var(--slider-bg); border: none; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); height: 10px; }
        
        .noUi-handle { 
            border: 1px solid var(--border-color); border-radius: 2px; background: var(--slider-handle-bg); 
            box-shadow: 0 1px 3px rgba(0,0,0,0.5); cursor: grab; width: 18px !important; height: 18px !important; top: -5px !important; 
        }
        .noUi-handle::before, .noUi-handle::after { display: none; }
        
        /* SLIDER TOOLTIPS - GENERAL */
        #balanceSlider .noUi-tooltip { 
            background: transparent; 
            color: var(--slider-tooltip-text); 
            font-size: 10px; 
            padding: 0; 
            border: none; 
            bottom: auto;
            top: 48px; 
            transform: rotate(-45deg) !important;
            transform-origin: center top !important;
            text-align: right; 
            white-space: nowrap;
        }
        #balanceSlider .noUi-handle-lower .noUi-tooltip { left: -35px; }

        /* Loading Overlay */
        #loading {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000; font-weight: bold; color: var(--primary);
            text-align: center;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.3s ease;
        }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
        .live-dot { height: 8px; width: 8px; background-color: var(--danger); border-radius: 50%; display: inline-block; margin-right: 5px; animation: pulse 1.5s infinite; }
        
        .breakdown-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }

        @media (max-width: 900px) { .charts-row { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            body { padding: 5px; }
            header { padding: 15px; flex-direction: column; align-items: flex-start; }
            header > div:first-child { width: 100%; }
            #status-placeholder { width: 100%; height: 50px; margin-top: 10px; }
            .status-floater { right: 60px; padding: 4px 8px; font-size: 0.75rem; width: auto; }
            .status-floater #latest-date-display { font-size: 1em; margin-bottom: 2px; }
            .status-floater .refresh-btn { font-size: 1em; padding: 1px 6px; }
            .stats-grid { grid-template-columns: 1fr 1fr; gap: 10px; } 
            .stat-card { padding: 12px 10px; }
            .stat-value { font-size: 1.4em; }
            .stat-label { font-size: 0.7em; }
            .chart-container { height: 250px !important; }
            .chart-container-tall { height: 550px !important; }
            #salary-trend-container { height: 500px !important; }
            .card { padding: 10px 5px; margin-bottom: 15px; }
            th, td { padding: 8px 4px; font-size: 0.75em; }
            .table-responsive { display: block; width: 100%; overflow-x: auto; }
            select#extrapolationRateSelect { max-width: 100%; font-size: 0.8em; }
            .breakdown-grid { grid-template-columns: 1fr; }
            .watchlist-split { grid-template-columns: 1fr; }
            .sticky-col-2 { left: 60px; }
        }
    </style>
</head>
<body class="sci-fi-mode"> <div id="loading">Loading Dashboard Data...</div>

<div class="theme-toggle" onclick="toggleTheme()" title="Switch View">
    <svg viewBox="0 0 24 24">
        <path d="M12,18C11.11,18 10.26,17.8 9.5,17.45C11.56,16.55 13,14.43 13,12C13,9.57 11.56,7.45 9.5,6.55C10.26,6.2 11.11,6 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z" />
    </svg>
</div>

<div id="status-floater" class="status-floater" style="top: 0px;">
    <div style="font-size: 0.9em; font-weight: bold; color: var(--danger); margin-bottom: 5px;" id="latest-date-display">
        <span class="live-dot"></span>Connecting...
    </div>
    <div style="display: flex; align-items: center; justify-content: flex-end; gap: 10px; width: 100%;">
        <button class="refresh-btn" onclick="manualRefresh()" id="manual-refresh-btn" style="margin:0;">
            <span>↻</span> Update
        </button>
        <div id="refresh-timer" style="font-size: 0.75em; color: #999;">Updates in 60s</div>
    </div>
</div>

<div class="container">
    <header>
        <div>
            <h1>Financial Dashboard</h1>
            <div class="subtitle">Investment Portfolio & Compensation Analysis</div>
        </div>
        <div id="status-placeholder"></div>
    </header>

    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-label">Total Net Worth</div>
            <div class="stat-value" id="stat-networth">-</div>
            <div class="stat-sub">Across all accounts</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Lifetime Gain</div>
            <div class="stat-value" id="stat-lifetime-gain">-</div>
            <div class="stat-sub">Cumulative Returns</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Latest Monthly P&L</div>
            <div class="stat-value" id="stat-monthly-pl">-</div>
            <div class="stat-sub">Market Change + Income</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Inflow (Latest)</div>
            <div class="stat-value" id="stat-monthly-inflow">-</div>
            <div class="stat-sub" id="stat-monthly-inflow-sub">-</div>
        </div>
    </div>

    <div class="card">
        <h3>Balance History (Stacked)</h3>
        <div class="chart-container chart-container-tall">
            <canvas id="balanceChart"></canvas>
        </div>
        <div style="padding: 10px 40px 60px 20px;">
            <div id="balanceSlider"></div>
        </div>
    </div>
    
    <div class="charts-row">
        <div class="card" style="overflow:hidden;">
            <h3>Live Market Watch</h3>
            <div class="subtitle" style="margin-bottom:15px">Current Positions Highlighted • Scroll for History</div>
            
            <div class="watchlist-controls">
                <input type="text" id="new-ticker-input" class="watchlist-input" placeholder="Symbol (e.g. NVDA)">
                <button class="btn-small" onclick="addTickerFromInput()"><i class="fas fa-plus"></i> Add</button>
                <button class="btn-small" id="trending-btn" onclick="toggleRedditTrending()" style="color:var(--goal); border-color:var(--goal)"><i class="fas fa-rocket"></i> Trending (Reddit)</button>
            </div>

            <div class="watchlist-split">
                <div class="watchlist-col gainers">
                    <h4>Top Gainers</h4>
                    <div class="watchlist-scroll-container" style="max-height: 400px;">
                        <table class="table-compact">
                            <thead>
                                <tr>
                                    <th class="sticky-col" style="text-align:left; min-width:70px;">Ticker</th>
                                    <th class="sticky-col-2" style="text-align:right; min-width:80px;">Price</th>
                                    <th style="text-align:right">% 1D</th>
                                    <th style="text-align:right">% 1W</th>
                                    <th style="text-align:right">% 1M</th>
                                    <th style="text-align:right">% 3M</th>
                                    <th style="text-align:right">% 6M</th>
                                    <th style="text-align:right">% 1Y</th>
                                    <th style="text-align:right">% 3Y</th>
                                    <th style="text-align:right">% 5Y</th>
                                    <th style="text-align:right">% Max</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody id="watchlist-gainers-body"></tbody>
                        </table>
                    </div>
                </div>

                <div class="watchlist-col losers">
                    <h4>Top Losers</h4>
                    <div class="watchlist-scroll-container" style="max-height: 400px;">
                        <table class="table-compact">
                            <thead>
                                <tr>
                                    <th class="sticky-col" style="text-align:left; min-width:70px;">Ticker</th>
                                    <th class="sticky-col-2" style="text-align:right; min-width:80px;">Price</th>
                                    <th style="text-align:right">% 1D</th>
                                    <th style="text-align:right">% 1W</th>
                                    <th style="text-align:right">% 1M</th>
                                    <th style="text-align:right">% 3M</th>
                                    <th style="text-align:right">% 6M</th>
                                    <th style="text-align:right">% 1Y</th>
                                    <th style="text-align:right">% 3Y</th>
                                    <th style="text-align:right">% 5Y</th>
                                    <th style="text-align:right">% Max</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody id="watchlist-losers-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
             <h3>Portfolio Settings</h3>
             <div class="subtitle" style="margin-bottom:15px">Override Holdings (Saved Locally)</div>
             
             <div class="filter-group" style="flex-direction:column; align-items:flex-start;">
                 <label style="width:100%">
                     <span class="filter-label">Account:</span>
                     <select id="config-account-select" class="watchlist-input" style="width:100%; margin-top:5px;"></select>
                 </label>
                 
                 <label style="width:100%">
                     <span class="filter-label">Ticker Symbol:</span>
                     <input type="text" id="config-ticker" class="watchlist-input" style="width:100%; margin-top:5px;" placeholder="e.g. VIGIX">
                 </label>
                 
                 <label style="width:100%">
                     <span class="filter-label">Quantity Held:</span>
                     <input type="number" step="0.001" id="config-qty" class="watchlist-input" style="width:100%; margin-top:5px;" placeholder="e.g. 150.25">
                 </label>

                 <button class="btn-small" onclick="saveAccountOverride()" style="width:100%; text-align:center; background:var(--primary); color:white;">Save Override</button>
                 <button class="btn-small" onclick="clearAccountOverride()" style="width:100%; text-align:center; margin-top:5px;">Clear Override</button>
             </div>
        </div>
    </div>

    <div class="charts-row">
        <div class="card">
            <h3 id="currentSnapshotHeader">Current Investment Breakdown (Latest Month)</h3>
            <div class="table-responsive">
                <table id="snapshotTable" class="table-compact">
                    <thead>
                        <tr>
                            <th>Account</th>
                            <th>Balance</th>
                            <th>1-Mo Gain</th>
                            <th>1-Mo Inflow</th> 
                            <th>Net Dep</th>
                            <th>Return</th>
                            <th>ROI</th> </tr>
                    </thead>
                    <tbody id="snapshotBody"></tbody>
                </table>
            </div>
            
            <h3 id="prevSnapshotHeader" style="margin-top: 30px; border-top: 2px solid var(--border-color); padding-top: 20px;">Previous Month Breakdown</h3>
            <div class="table-responsive">
                <table id="prevSnapshotTable" class="table-compact">
                    <thead>
                        <tr>
                            <th>Account</th>
                            <th>Balance</th>
                            <th>1-Mo Gain</th>
                            <th>1-Mo Inflow</th> 
                            <th>Net Dep</th>
                            <th>Return</th>
                            <th>ROI</th> </tr>
                    </thead>
                    <tbody id="prevSnapshotBody"></tbody>
                </table>
            </div>
        </div>
        
        <div class="card">
            <h3>Asset Allocation</h3>
            <div class="chart-container">
                <canvas id="allocationChart"></canvas>
            </div>
        </div>
    </div>

    <div class="card">
        <h3>Monthly Profit/Loss Analysis (Investments)</h3>
        <div class="chart-container">
            <canvas id="plChart"></canvas>
        </div>
    </div>

    <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center;">
             <h3>Yearly Performance Analysis (TWR)</h3>
             <div style="text-align:right;">
                 <div style="font-size:0.7em; color:#7f8c8d; text-transform:uppercase;">Overall Average</div>
                 <div style="font-size:1.2em; font-weight:bold; color:var(--primary);" id="stat-avg-yearly-return">-</div>
             </div>
        </div>
        <div class="chart-container">
            <canvas id="yearlyReturnChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3>Wells Fargo Monthly Withdrawals (Last 24 Months)</h3>
        <div class="chart-container chart-container-small">
            <canvas id="wfWithdrawalChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3>Investment History Details</h3>
        <div class="table-responsive" style="max-height: 400px;">
            <table id="historyTable" class="table-compact">
                <thead>
                    <tr id="historyHeader">
                        <th>Month</th>
                        <th>Total Balance</th>
                        <th>Total Gain/Loss</th>
                        </tr>
                </thead>
                <tbody id="historyBody"></tbody>
            </table>
        </div>
    </div>

    <div class="section-header">
        Compensation History
    </div>

    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-label">Latest Base Salary</div>
            <div class="stat-value" id="stat-salary-base">-</div>
            <div class="stat-sub" id="stat-salary-date">As of -</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Proj. Total Comp (2025)</div>
            <div class="stat-value" id="stat-total-comp">-</div>
            <div class="stat-sub">Base + Match + Bonus + Edu</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Education Benefits (YTD)</div>
            <div class="stat-value" id="stat-edu-ytd">-</div>
            <div class="stat-sub">Tuition Reimbursement</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Match Rate</div>
            <div class="stat-value" id="stat-match-rate">-</div>
            <div class="stat-sub">Of Base Salary</div>
        </div>
    </div>

    <div class="charts-row">
        <div class="card">
            <h3>Salary vs. Total Compensation Trends (Stacked)</h3>
            <div class="chart-container" id="salary-trend-container">
                <canvas id="salaryTrendChart"></canvas>
            </div>
        </div>
        <div class="card">
            <h3>Compensation Components (Latest YTD)</h3>
            <div class="chart-container">
                <canvas id="compBreakdownChart"></canvas>
            </div>
        </div>
    </div>

    <div class="card" style="padding-bottom:10px;">
        <h3 style="margin-bottom:10px">Income Analysis Controls</h3>
        <div class="filter-group" id="income-filter-container">
            <span class="filter-label">Include Deposits From:</span>
            </div>
    </div>

    <div class="card" style="display:flex; align-items:center; justify-content:space-between; background:var(--bg);">
        <div>
            <h3 style="margin:0; border:none; padding:0;">Trailing 12-Month After-Tax Income</h3>
            <div class="subtitle">Total liquid deposits (Based on selection above)</div>
        </div>
        <div style="text-align:right;">
             <div style="font-size:2em; font-weight:bold; color:var(--success);" id="stat-12mo-income">-</div>
             <div style="font-size:0.8em; color:#7f8c8d;">Last 12 Months</div>
        </div>
    </div>

    <div class="card">
        <h3>Monthly After-Tax Income (Last 24 Months)</h3>
        <div class="subtitle" style="margin-bottom:15px">Sum of deposits for selected accounts</div>
        <div class="chart-container">
            <canvas id="incomeTrendChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3>Compensation History Details</h3>
        <div class="table-responsive" style="max-height: 400px;">
            <table id="salaryTable" class="table-compact">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Base Salary</th>
                        <th>Match</th>
                        <th>Bonus</th>
                        <th>Education</th>
                        <th>Total Comp</th>
                    </tr>
                </thead>
                <tbody id="salaryBody"></tbody>
            </table>
        </div>
    </div>

    <div class="card" style="padding-bottom:10px;">
        <h3 style="margin-bottom:10px">+25 Year Extrapolation Controls</h3>
        
        <div class="filter-group" style="margin-bottom: 10px;">
            <span class="filter-label">Payday Anchor (Bi-weekly):</span>
            <input type="date" id="paydayAnchor" value="2026-01-10" style="padding:5px; border-radius:4px; border:1px solid #ccc; font-family:inherit;" oninput="handleUserProjectionChange()">
        </div>

        <div class="filter-group" style="margin-bottom: 10px;">
            <span class="filter-label">Custom Goal ($):</span>
            <input type="number" id="customGoalInput" value="1000000" step="10000" style="padding:5px; border-radius:4px; border:1px solid #ccc; font-family:inherit; width:120px;" oninput="handleUserProjectionChange()">
        </div>

        <div class="filter-group">
            <span class="filter-label">Select Annual Return:</span>
            
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.05" onchange="handleUserProjectionChange()"> 5%
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.075" onchange="handleUserProjectionChange()"> 7.5%
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.1" checked onchange="handleUserProjectionChange()"> 10% (Baseline)
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.125" onchange="handleUserProjectionChange()"> 12.5%
            </label>
            <label class="radio-label">
                <input type="radio" name="extrapolationRate" value="0.15" onchange="handleUserProjectionChange()"> 15%
            </label>
        </div>
    </div>

    <div class="stats-grid">
         <div class="stat-card">
            <div class="stat-label" id="card-nw-label">Projected Net Worth (10%)</div>
            <div class="stat-value" id="proj-nw-card">-</div>
            <div class="stat-sub">In 25 Years</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Porsche Purchase</div>
            <div style="font-size:0.9em; font-weight:bold; margin-top:4px; color:var(--text);">$3M Goal</div>
            <div style="font-size:0.9em; font-weight:bold; color:var(--danger);">$300k Cost</div>
            <div class="stat-value" id="proj-porsche-date">-</div>
            <div class="stat-sub" id="proj-porsche-countdown" style="font-weight:bold; color:var(--primary); font-size:0.9em; margin-bottom:2px">-</div>
            <div class="stat-sub" id="proj-porsche-sub">Estimated Date</div>
        </div>
         <div class="stat-card">
            <div class="stat-label">Beach House</div>
            <div style="font-size:0.9em; font-weight:bold; margin-top:4px; color:var(--text);">$10M Goal</div>
            <div style="font-size:0.9em; font-weight:bold; color:var(--danger);">$5M Cost</div>
            <div class="stat-value" id="proj-house-date">-</div>
            <div class="stat-sub" id="proj-house-countdown" style="font-weight:bold; color:var(--primary); font-size:0.9em; margin-bottom:2px">-</div>
            <div class="stat-sub" id="proj-house-sub">Estimated Date</div>
        </div>
         <div class="stat-card">
            <div class="stat-label">Custom Goal</div>
            <div style="font-size:0.9em; font-weight:bold; margin-top:4px; color:var(--text);" id="custom-goal-display">$1M Goal</div>
            <div style="font-size:0.9em; font-weight:bold; color:transparent; user-select:none;">-</div>
            <div class="stat-value" id="proj-custom-date">-</div>
            <div class="stat-sub" id="proj-custom-countdown" style="font-weight:bold; color:var(--primary); font-size:0.9em; margin-bottom:2px">-</div>
            <div class="stat-sub" id="proj-custom-sub">Estimated Date</div>
        </div>
    </div>

    <div class="card">
        <h3>Net Worth Projection (Range: 5% - 15% Annual Return)</h3>
        <div id="chart-subtitle-text" style="text-align: center; font-size: 0.85em; color: #7f8c8d; margin-bottom: 10px;">
            Baseline: Current Net Worth + Bi-Weekly Contributions (Derived from latest inflow)
        </div>
        <div class="chart-container chart-container-tall">
            <canvas id="projectionChart"></canvas>
        </div>
    </div>

    <div class="card">
        <h3 style="margin-bottom:15px; border-bottom:1px solid var(--border-color); padding-bottom:10px;">Detailed Projection Breakdown</h3>
        
        <div style="background:var(--bg); padding:15px; border-radius:6px; margin-bottom:20px; font-size:0.9em; line-height:1.6; color:var(--text); border:1px solid var(--border-color);">
            <div class="breakdown-grid">
                <div>
                    <strong style="color:var(--primary); text-transform:uppercase;">1. The Math Behind the Numbers</strong><br>
                    Future values are calculated using monthly compounding:<br>
                    <code style="background:var(--card-bg); padding:2px 4px; border-radius:3px; color:var(--danger); font-family:monospace; display:block; margin:5px 0;">
                        Balance(t) = Balance(t-1) × (1 + Rate/12) + Contrib(t)
                    </code>
                    <ul>
                        <li><strong>Balance(t-1):</strong> Previous month's ending balance.</li>
                        <li><strong>Rate:</strong> Annual return selected above (e.g., 0.10 for 10%).</li>
                        <li><strong>Contrib(t):</strong> Total cash added that month.</li>
                    </ul>
                </div>
                <div>
                    <strong style="color:var(--primary); text-transform:uppercase;">2. Contribution Assumptions</strong><br>
                    <ul>
                        <li><strong>Baseline Per Paycheck:</strong> <span id="per-paycheck-amt" style="font-weight:bold; color:var(--success)">-</span> (Adjusted for Jan Raise)</li>
                        <li><strong>Payday Anchor:</strong> The date selected (e.g., Jan 10, 2026) determines exactly which months have 3 paychecks vs. 2. The model adjusts monthly contributions accordingly.</li>
                    </ul>
                </div>
                <div>
                    <strong style="color:var(--primary); text-transform:uppercase;">3. "Save The Raise" Strategy</strong><br>
                    We assume zero lifestyle inflation. 100% of every future raise is added directly to your investment contribution.<br>
                    <ul>
                        <li><strong>Raises Applied:</strong> <span id="jan-raise-display">6.0%</span> in January, <span id="july-raise-display">3.0%</span> in July.</li>
                        <li><strong>Calculation:</strong> <code>RaiseAmount = CurrentBaseSalary × Raise%</code>.</li>
                        <li><strong>Result:</strong> This specific dollar amount is added to every future paycheck contribution permanently.</li>
                    </ul>
                </div>
                <div>
                    <strong style="color:var(--primary); text-transform:uppercase;">4. Asset Purchases & Net Worth</strong><br>
                    When goals are hit (Porsche/Beach House), cash is "spent":
                    <ul>
                        <li><strong>Liquid NW:</strong> Drops by the cost of the asset ($300k or $5M).</li>
                        <li><strong>Total NW:</strong> Remains consistent, as the cash is converted into a fixed asset value included in the total.</li>
                    </ul>
                </div>
            </div>
        </div>
    
        <div class="table-responsive" style="max-height: 500px;">
            <table id="projectionTable" class="table-compact">
                <thead>
                    <tr>
                        <th style="width:10%">Year</th>
                        <th style="width:20%">Start Balance</th>
                        <th style="width:25%">Annual Contribution</th>
                        <th style="width:25%">Est. Market Growth</th>
                        <th style="width:20%">End Balance</th>
                    </tr>
                </thead>
                <tbody id="projectionTableBody"></tbody>
            </table>
        </div>
    </div>

</div>

<script>
    // ==========================================
    // FLUID STATUS BOX POSITIONING LOGIC
    // ==========================================
    let isDockedState = false; 
    let initialPlaceholderTop = 0;
    let isInitialized = false;
    let scrollRaf = null;

    function measurePlaceholder() {
        const placeholder = document.getElementById('status-placeholder');
        const floater = document.getElementById('status-floater');
        if (!placeholder || !floater) return;

        const rect = placeholder.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        initialPlaceholderTop = rect.top + scrollTop;
        
        if (!floater.classList.contains('docked')) {
            floater.style.top = initialPlaceholderTop + 'px';
        }
        isInitialized = true;
    }

    function onScroll() {
        if (!scrollRaf) {
            scrollRaf = requestAnimationFrame(() => {
                updateStatusPosition();
                scrollRaf = null;
            });
        }
    }

    function updateStatusPosition() {
        if (!isInitialized) measurePlaceholder();

        const floater = document.getElementById('status-floater');
        if (!floater) return;

        const scrollY = window.scrollY;
        const dockThreshold = initialPlaceholderTop - 15;

        if (scrollY > dockThreshold) {
            if (!isDockedState) {
                floater.classList.add('docked');
                floater.style.top = ''; 
                isDockedState = true;
            }
        } else {
            if (isDockedState) {
                floater.classList.remove('docked');
                floater.style.top = initialPlaceholderTop + 'px';
                isDockedState = false;
            }
        }
    }

    window.addEventListener('scroll', onScroll);
    window.addEventListener('resize', () => {
        measurePlaceholder();
        updateStatusPosition();
    });
    window.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            measurePlaceholder();
            updateStatusPosition();
        }, 100);
    });
    window.onload = () => {
        measurePlaceholder();
        updateStatusPosition();
    };


    // ==========================================
    // THEME HANDLING
    // ==========================================
    let isSciFiMode = true; 

    const palette = ['#3498db', '#9b59b6', '#2ecc71', '#e67e22', '#f1c40f', '#e74c3c'];

    let globalJanRaise = 0.06;
    let globalJulyRaise = 0.03;
    let globalLatestBaseSalary = 130000; 
    let globalPrevBaseSalary = 110300; 
    
    // NEW GLOBALS FOR INSTANT PROJECTION RECALC
    let g_lastBalance = 0;
    let g_lastInflow = 0;
    let g_lastDateStr = "";
    
    // WATCHLIST & CONFIG
    let userWatchlist = JSON.parse(localStorage.getItem('userWatchlist')) || ['VIGIX', 'VTSAX', 'GOOGL', 'TSLA', 'NVDA', 'BND'];
    let accountOverrides = JSON.parse(localStorage.getItem('accountOverrides')) || {};
    
    // NEW: TRACK VESTED STOCKS
    let vestedTickers = new Set();

    // TRENDING CONSTANTS
    const redditTrending = ['NVDA', 'TSLA', 'PLTR', 'GME', 'AMD', 'AAPL', 'MSFT', 'AMZN', 'COIN', 'MSTR'];

    function toggleTheme() {
        isSciFiMode = !isSciFiMode;
        document.body.classList.toggle('sci-fi-mode');
        updateChartStyles();
        
        if(globalAccountsData && globalAccountsData.length > 0) {
            processAndRender(globalAccountsData, true);
        }
        renderWatchlistColumns();
        
        setTimeout(measurePlaceholder, 300);
    }

    function updateChartStyles() {
        Chart.defaults.color = isSciFiMode ? '#ecf0f1' : '#2c3e50';
        Chart.defaults.borderColor = isSciFiMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

        const textColor = isSciFiMode ? '#ecf0f1' : '#2c3e50';
        const gridColor = isSciFiMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

        Object.values(charts).forEach(chart => {
            if (!chart) return;

            if (chart.options.scales) {
                ['x', 'y'].forEach(axis => {
                    if (chart.options.scales[axis]) {
                        if (chart.options.scales[axis].ticks) chart.options.scales[axis].ticks.color = textColor;
                        if (chart.options.scales[axis].grid) chart.options.scales[axis].grid.color = gridColor;
                        if (chart.options.scales[axis].title) chart.options.scales[axis].title.color = textColor;
                    }
                });
            }

            if (chart.options.plugins) {
                if (chart.options.plugins.legend) {
                     chart.options.plugins.legend.labels.color = textColor;
                }
                if (chart.options.plugins.title) {
                    chart.options.plugins.title.color = textColor;
                }
                if (chart.options.plugins.datalabels) {
                    chart.options.plugins.datalabels.color = textColor;
                }
            }
            
            if (chart.canvas.id === 'balanceChart') {
                if (chart.options.plugins && chart.options.plugins.datalabels) {
                    if (isSciFiMode) {
                        chart.options.plugins.datalabels.backgroundColor = function(context) {
                            return context.dataset.backgroundColor;
                        };
                        chart.options.plugins.datalabels.borderColor = function(context) {
                            return context.dataset.borderColor;
                        };
                        chart.options.plugins.datalabels.color = '#ffffff'; 
                    } else {
                        chart.options.plugins.datalabels.backgroundColor = 'white';
                        chart.options.plugins.datalabels.borderColor = function(context) {
                            return context.dataset.borderColor;
                        };
                        chart.options.plugins.datalabels.color = 'black';
                    }
                }
            } else {
                 if (chart.options.plugins && chart.options.plugins.datalabels) {
                    chart.options.plugins.datalabels.color = textColor;
                }
            }

            chart.update();
        });
    }


    // ==========================================
    // DATA SOURCES
    // ==========================================
    
    const API_URL = 'https://script.google.com/macros/s/AKfycbxEzEutSYlhftlhNq_EI-dJRwARlcB00enAAm_9pkDxX5m8mhdtr8OsRx1rzneN4gXy/exec';

    const TICKER_MAP = {
        'VIGIX': 'VIGIX',
        'VTSAX': 'VTSAX',
        'GOOGL': 'GOOGL',
        'Fidelity (GOOGL)': 'GOOGL',
        'Boeing (Bonds)': 'BND',    
        'Wells Fargo (Cash)': 'BIL' 
    };

    let projectionDataStore = {};
    let projectionMetadata = {}; 
    let globalAccountsData = []; 
    let charts = {};
    let watchlistDataStore = [];

    let refreshInterval = null;
    let refreshTimer = 60;
    let isUpdating = false;

    // ==========================================
    // UTILITIES
    // ==========================================
    const isMobile = window.innerWidth <= 768;

    function cleanMoney(str) {
        if (!str) return 0;
        const s = String(str).replace(/[$,"]/g, '').trim();
        return parseFloat(s) || 0;
    }

    function cleanPercent(str) {
        if (!str) return 0;
        const s = String(str).replace(/[%"]/g, '').trim();
        return parseFloat(s) || 0;
    }

    function fmtMoney(num) {
        return '$' + num.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function fmtMoneySimple(num) {
        return '$' + num.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
    }

    function formatCountdown(targetDate) {
        if (!targetDate) return "N/A";
        const now = new Date();
        if (targetDate <= now) return "Achieved!";
        let years = targetDate.getFullYear() - now.getFullYear();
        let months = targetDate.getMonth() - now.getMonth();
        if (months < 0) { years--; months += 12; }
        return `${years} Years, ${months} Months remaining`;
    }

    // ==========================================
    // WATCHLIST & OVERRIDES LOGIC
    // ==========================================
    
    function addTickerFromInput() {
        const input = document.getElementById('new-ticker-input');
        const ticker = input.value.trim().toUpperCase();
        if(ticker && !userWatchlist.includes(ticker)) {
            userWatchlist.push(ticker);
            localStorage.setItem('userWatchlist', JSON.stringify(userWatchlist));
            input.value = '';
            manualRefresh(); 
        }
    }
    
    function removeTicker(ticker) {
        userWatchlist = userWatchlist.filter(t => t !== ticker);
        localStorage.setItem('userWatchlist', JSON.stringify(userWatchlist));
        updateTrendingButtonState();
        manualRefresh(); 
    }
    
    function updateTrendingButtonState() {
        // Check if any trending stocks are present
        const hasTrending = redditTrending.some(t => userWatchlist.includes(t));
        const btn = document.getElementById('trending-btn');
        if(hasTrending) {
             btn.innerHTML = '<i class="fas fa-trash-alt"></i> Remove Trending';
             btn.classList.add('btn-active');
        } else {
             btn.innerHTML = '<i class="fas fa-rocket"></i> Trending (Reddit)';
             btn.classList.remove('btn-active');
        }
    }
    
    function toggleRedditTrending() {
        const hasTrending = redditTrending.some(t => userWatchlist.includes(t));
        
        if (hasTrending) {
            // Remove all reddit trending stocks
            userWatchlist = userWatchlist.filter(t => !redditTrending.includes(t));
        } else {
            // Add them
            redditTrending.forEach(t => {
                if(!userWatchlist.includes(t)) userWatchlist.push(t);
            });
        }
        
        localStorage.setItem('userWatchlist', JSON.stringify(userWatchlist));
        updateTrendingButtonState();
        manualRefresh();
    }
    
    function initPortfolioConfig() {
        const select = document.getElementById('config-account-select');
        select.innerHTML = '<option value="">Select Account...</option>';
        globalAccountsData.forEach(acc => {
            const opt = document.createElement('option');
            opt.value = acc.id;
            opt.innerText = acc.name;
            select.appendChild(opt);
        });
        
        select.addEventListener('change', () => {
             const val = select.value;
             const saved = accountOverrides[val];
             if(saved) {
                 document.getElementById('config-ticker').value = saved.ticker || '';
                 document.getElementById('config-qty').value = saved.qty || '';
             } else {
                 document.getElementById('config-ticker').value = '';
                 document.getElementById('config-qty').value = '';
             }
        });
        
        updateTrendingButtonState();
    }
    
    function saveAccountOverride() {
        const accId = document.getElementById('config-account-select').value;
        const ticker = document.getElementById('config-ticker').value.trim().toUpperCase();
        const qty = parseFloat(document.getElementById('config-qty').value);
        
        if(!accId) return alert("Please select an account.");
        
        if(ticker || !isNaN(qty)) {
            accountOverrides[accId] = { ticker: ticker, qty: qty };
            localStorage.setItem('accountOverrides', JSON.stringify(accountOverrides));
            
            // Apply immediately to global data
            const acc = globalAccountsData.find(a => a.id === accId);
            if(acc) {
                processAndRender(globalAccountsData, true);
                alert("Saved! Dashboard updated.");
            }
        }
    }
    
    function clearAccountOverride() {
        const accId = document.getElementById('config-account-select').value;
        if(accId && accountOverrides[accId]) {
            delete accountOverrides[accId];
            localStorage.setItem('accountOverrides', JSON.stringify(accountOverrides));
            document.getElementById('config-ticker').value = '';
            document.getElementById('config-qty').value = '';
            processAndRender(globalAccountsData, true);
        }
    }

    // ==========================================
    // LOGIC: REAL-TIME MARKET DATA (UPDATED)
    // ==========================================
    
    // HELPER: Find close price N days ago
    function getPriceAtOffset(closes, timestamps, targetDate) {
        let price = null;
        for (let i = timestamps.length - 1; i >= 0; i--) {
            const d = new Date(timestamps[i] * 1000);
            if (d <= targetDate && closes[i] !== null) {
                price = closes[i];
                break;
            }
        }
        return price;
    }

    async function getStockPerformance(ticker) {
        if (!ticker || ticker === 'Unknown' || ticker === '-') return null;
        const cleanTicker = TICKER_MAP[ticker] || ticker.split(' ')[0]; 

        const proxies = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/get?url=',
            'https://thingproxy.freeboard.io/fetch/' 
        ];

        const cacheBuster = `&_=${new Date().getTime()}`;
        
        // UPGRADE: Fetch 'max' range to compute all stats
        const targetUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${cleanTicker}?range=max&interval=1d${cacheBuster}`;

        for (const proxy of proxies) {
            try {
                let fetchUrl = proxy.includes('allorigins') ? proxy + encodeURIComponent(targetUrl) : proxy + targetUrl;
                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error('Network');
                
                let data = proxy.includes('allorigins') ? JSON.parse((await response.json()).contents) : await response.json();

                if (!data.chart || !data.chart.result || data.chart.result.length === 0) continue;

                const quote = data.chart.result[0];
                const timestamps = quote.timestamp;
                const closes = quote.indicators.quote[0].close;

                if (!closes || closes.length === 0) continue;
                
                // Current Price
                let currentPrice = null;
                let lastIndex = -1;
                for (let i = closes.length - 1; i >= 0; i--) {
                    if (closes[i] !== null) { 
                        currentPrice = closes[i]; 
                        lastIndex = i;
                        break; 
                    }
                }
                
                if (!currentPrice) continue;
                
                // DATA POINT: MTD BASELINE (Start of Current Month)
                const now = new Date();
                const startOfCurrentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                const baselinePrice = getPriceAtOffset(closes, timestamps, startOfCurrentMonth);

                // DATA POINTS: HISTORICAL OFFSETS
                // 1D (Prev Close), 1W, 1M, 3M, 6M, 1Y, 3Y, 5Y, Max
                
                // Prev Close (Robust check)
                let prevClose = null;
                if (lastIndex > 0) {
                     for (let j = lastIndex - 1; j >= 0; j--) {
                         if (closes[j] !== null) { prevClose = closes[j]; break; }
                     }
                }
                if(!prevClose) prevClose = quote.meta.chartPreviousClose;
                
                const dayRate = (prevClose && currentPrice) ? (currentPrice - prevClose) / prevClose : 0;
                
                const getDateAgo = (days) => {
                    const d = new Date();
                    d.setDate(d.getDate() - days);
                    return d;
                };

                const p1w = getPriceAtOffset(closes, timestamps, getDateAgo(7));
                const p1m = getPriceAtOffset(closes, timestamps, getDateAgo(30));
                const p3m = getPriceAtOffset(closes, timestamps, getDateAgo(90));
                const p6m = getPriceAtOffset(closes, timestamps, getDateAgo(180));
                const p1y = getPriceAtOffset(closes, timestamps, getDateAgo(365));
                const p3y = getPriceAtOffset(closes, timestamps, getDateAgo(365*3));
                const p5y = getPriceAtOffset(closes, timestamps, getDateAgo(365*5));
                
                // Find first valid close for MAX
                let pMax = null;
                for(let k=0; k < closes.length; k++) {
                    if(closes[k] !== null) { pMax = closes[k]; break; }
                }

                const calcRate = (base) => (base && currentPrice) ? (currentPrice - base) / base : null;

                const lastTimestamp = timestamps[timestamps.length - 1];

                return { 
                    price: currentPrice,
                    prevClose: prevClose,
                    mtdRate: (baselinePrice && currentPrice) ? (currentPrice - baselinePrice) / baselinePrice : 0, // For Account Balances
                    
                    // For Watchlist
                    dayRate: dayRate,
                    w1Rate: calcRate(p1w),
                    m1Rate: calcRate(p1m),
                    m3Rate: calcRate(p3m),
                    m6Rate: calcRate(p6m),
                    y1Rate: calcRate(p1y),
                    y3Rate: calcRate(p3y),
                    y5Rate: calcRate(p5y),
                    maxRate: calcRate(pMax),
                    
                    ts: lastTimestamp 
                };

            } catch (e) {
                console.warn(`Proxy failed for ${cleanTicker}`);
            }
        }
        return null; 
    }

    async function updateWithLiveMarketData(accounts, isSilent = false) {
        if (isUpdating) return;
        isUpdating = true;
        
        const statusDiv = document.getElementById('loading');
        const headerStatus = document.getElementById('latest-date-display');
        const btn = document.getElementById('manual-refresh-btn');
        
        if (!isSilent) {
            statusDiv.style.opacity = '1';
            statusDiv.style.display = 'flex';
            statusDiv.innerHTML = "Fetching Real-Time Market Data...<br><span style='font-size:0.8em; font-weight:normal'>Updating Portfolio & Watchlist...</span>";
        } else {
            headerStatus.innerHTML = "<span class='live-dot'></span> Updating...";
            headerStatus.style.color = "#e67e22";
            if(btn) btn.innerHTML = "<span>↻</span> ...";
        }
        
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonthVal = now.getMonth() + 1; 
        const currentMonthKey = `${currentYear}-${String(currentMonthVal).padStart(2, '0')}`;
        
        // RESET VESTED TRACKER
        vestedTickers = new Set();
        
        // ACCOUNT FETCH
        try {
            // First, process accounts to populate vestedTickers and account data
            await Promise.all(accounts.map(async (acc) => {
                if (acc.data.length === 0) return;
                
                // CHECK FOR OVERRIDE TICKER
                const override = accountOverrides[acc.id];
                let ticker = override ? override.ticker : null;

                const startOfThisMonth = new Date(currentYear, currentMonthVal - 1, 1);
                let baselineEntry = null;
                for (let i = acc.data.length - 1; i >= 0; i--) {
                    if (acc.data[i].dateObj < startOfThisMonth) {
                        baselineEntry = acc.data[i];
                        break;
                    }
                }

                if (!baselineEntry) return;

                let liveEntry = acc.data.find(d => d.key === currentMonthKey);
                let isNewRow = false;

                if (!liveEntry) {
                    isNewRow = true;
                    liveEntry = {
                        key: currentMonthKey,
                        dateObj: startOfThisMonth,
                        deposits: 0,
                        income: 0,
                        marketGain: 0,
                        cumulative: baselineEntry.cumulative,
                        balance: baselineEntry.balance,
                        invested: baselineEntry.invested,
                        rawWithdrawals: 0, 
                        isLive: true,
                        isError: false,
                        timestamp: 0 
                    };
                } else {
                    liveEntry.isLive = true;
                    liveEntry.isError = false;
                }

                if(!ticker) {
                    ticker = liveEntry.invested; 
                    if (acc.id.includes('fidelity')) ticker = 'GOOGL';
                    if (acc.id.includes('boeing')) ticker = 'BND'; // Corrected map
                    if (acc.id.includes('wells')) ticker = 'BIL';
                }
                
                // Add to vested list if balance > 0
                if(baselineEntry.balance > 0) {
                     vestedTickers.add(ticker);
                     // Also add the override ticker if it exists
                     if(override && override.ticker) vestedTickers.add(override.ticker);
                     // Also add the raw invested ticker just in case
                     if(liveEntry.invested && liveEntry.invested !== 'Unknown') vestedTickers.add(liveEntry.invested);
                }

                const marketData = await getStockPerformance(ticker);
                
                if (marketData === null) {
                    liveEntry.isError = true;
                    if (isNewRow) {
                        liveEntry.marketGain = 0;
                        liveEntry.balance = baselineEntry.balance + liveEntry.deposits + liveEntry.income;
                    }
                } else {
                    const growthAmount = baselineEntry.balance * marketData.mtdRate;
                    liveEntry.marketGain = growthAmount; 
                    liveEntry.balance = baselineEntry.balance + growthAmount + liveEntry.deposits + liveEntry.income;
                    liveEntry.cumulative = baselineEntry.cumulative + growthAmount + liveEntry.income;
                    liveEntry.timestamp = marketData.ts;
                    // IF OVERRIDE QTY EXISTS, RECALCULATE BALANCE BASED ON PRICE * QTY
                    if(override && override.qty) {
                         liveEntry.balance = marketData.price * override.qty;
                         liveEntry.marketGain = liveEntry.balance - liveEntry.deposits - liveEntry.income - baselineEntry.balance; 
                         liveEntry.cumulative = baselineEntry.cumulative + liveEntry.marketGain + liveEntry.income; 
                    }
                }

                if (isNewRow) {
                    acc.data.push(liveEntry);
                }
            }));
            
            // ENSURE WATCHLIST HAS ALL VESTED TICKERS
            vestedTickers.forEach(vt => {
                if(vt && vt !== 'Unknown' && !userWatchlist.includes(vt) && vt !== '-' && vt !== 'BIL') { // Exclude cash equivalents if desired, here I keep them except BIL/Cash logic if wanted
                     userWatchlist.push(vt);
                }
            });
            localStorage.setItem('userWatchlist', JSON.stringify(userWatchlist));

            // NOW FETCH WATCHLIST (After Vested Tickers are added)
            watchlistDataStore = [];
             await Promise.all(userWatchlist.map(async (ticker) => {
                 const data = await getStockPerformance(ticker);
                 if(data) {
                     watchlistDataStore.push({
                         ticker: ticker,
                         price: data.price,
                         dayChange: data.dayRate,
                         // Expanded Data
                         w1: data.w1Rate,
                         m1: data.m1Rate,
                         m3: data.m3Rate,
                         m6: data.m6Rate,
                         y1: data.y1Rate,
                         y3: data.y3Rate,
                         y5: data.y5Rate,
                         max: data.maxRate
                     });
                 } else {
                      watchlistDataStore.push({ ticker: ticker, price: 0, dayChange: 0, error: true });
                 }
             }));
             renderWatchlistColumns();

        } catch (e) {
            console.error(e);
        } finally {
            isUpdating = false;
            if(btn) btn.innerHTML = "<span>↻</span> Update";
        }
    }
    
    function renderWatchlistColumns() {
        // Filter into two arrays
        const gainers = watchlistDataStore.filter(i => i.dayChange >= 0).sort((a,b) => b.dayChange - a.dayChange);
        const losers = watchlistDataStore.filter(i => i.dayChange < 0).sort((a,b) => a.dayChange - b.dayChange); // Worst first

        const fillBody = (items, bodyId) => {
            const body = document.getElementById(bodyId);
            body.innerHTML = '';
            items.forEach(item => {
                const tr = document.createElement('tr');
                
                // CHECK IF VESTED
                if(vestedTickers.has(item.ticker)) {
                    tr.classList.add('vested-row');
                }

                const formatCell = (val) => {
                    if (val === null || val === undefined) return '<span style="color:#777">-</span>';
                    const colorClass = val >= 0 ? 'text-green' : 'text-red';
                    const sign = val >= 0 ? '+' : '';
                    const pct = (val * 100).toFixed(2) + '%';
                    return `<span class="${colorClass}">${sign}${pct}</span>`;
                };
                
                // Sticky Columns
                const tickerCell = `<td class="sticky-col" style="font-weight:bold">${item.ticker}</td>`;
                const priceCell = `<td class="sticky-col-2" style="font-weight:bold">${fmtMoney(item.price)}</td>`;
                
                // Scrollable Columns
                const dataCells = `
                    <td>${formatCell(item.dayChange)}</td>
                    <td>${formatCell(item.w1)}</td>
                    <td>${formatCell(item.m1)}</td>
                    <td>${formatCell(item.m3)}</td>
                    <td>${formatCell(item.m6)}</td>
                    <td>${formatCell(item.y1)}</td>
                    <td>${formatCell(item.y3)}</td>
                    <td>${formatCell(item.y5)}</td>
                    <td>${formatCell(item.max)}</td>
                `;

                const btnCell = `
                    <td style="text-align:center">
                        <button onclick="removeTicker('${item.ticker}')" style="background:transparent; border:none; color:var(--text); opacity:0.5; cursor:pointer;" title="Remove">
                            <i class="fas fa-times"></i>
                        </button>
                    </td>
                `;
                
                tr.innerHTML = tickerCell + priceCell + dataCells + btnCell;
                body.appendChild(tr);
            });
        };

        fillBody(gainers, 'watchlist-gainers-body');
        fillBody(losers, 'watchlist-losers-body');
    }
    
    async function manualRefresh() {
        if(isUpdating) return;
        await updateWithLiveMarketData(globalAccountsData, true);
        processAndRender(globalAccountsData, true);
        const isMarket = isMarketOpen();
        refreshTimer = isMarket ? 10 : 60;
    }

    // ==========================================
    // LOGIC: SALARY 
    // ==========================================
    function processSalaryData(rows) {
        if (!rows || rows.length < 2) {
            document.getElementById('stat-salary-base').innerText = "No Data";
            return;
        }

        const data = rows.slice(1).map(r => ({
            year: r[0], date: r[1],
            salary: cleanMoney(r[2]), matchPct: cleanPercent(r[3]), matchAmt: cleanMoney(r[4]),
            bonus: cleanMoney(r[5]), ytdBonus: cleanMoney(r[6]),
            edu: cleanMoney(r[7]), ytdEdu: cleanMoney(r[8]),
            recurring: cleanMoney(r[9]), totalComp: cleanMoney(r[11])
        }));

        data.sort((a,b) => new Date(a.date) - new Date(b.date));
        
        const now = new Date();
        const currentYear = now.getFullYear();

        let targetJan = new Date(currentYear, 0, 1);
        if (now < targetJan) targetJan = new Date(currentYear - 1, 0, 1); 

        let targetJuly = new Date(currentYear, 6, 1);
        if (now < targetJuly) targetJuly = new Date(currentYear - 1, 6, 1);

        let closestJanEntry = null;
        let minJanDiff = Infinity;
        let closestJanIndex = -1;

        let closestJulyEntry = null;
        let minJulyDiff = Infinity;
        let closestJulyIndex = -1;

        data.forEach((d, index) => {
            const dDate = new Date(d.date);
            const diffJan = Math.abs(dDate - targetJan);
            const diffJuly = Math.abs(dDate - targetJuly);
            
            if (diffJan < minJanDiff) { minJanDiff = diffJan; closestJanEntry = d; closestJanIndex = index; }
            if (diffJuly < minJulyDiff) { minJulyDiff = diffJuly; closestJulyEntry = d; closestJulyIndex = index; }
        });

        if (closestJanIndex > 0) {
            const prev = data[closestJanIndex - 1];
            if (prev.salary > 0) globalJanRaise = (closestJanEntry.salary - prev.salary) / prev.salary;
        }
        if (closestJulyIndex > 0) {
            const prev = data[closestJulyIndex - 1];
            if (prev.salary > 0) globalJulyRaise = (closestJulyEntry.salary - prev.salary) / prev.salary;
        }
        
        const janPctText = (globalJanRaise * 100).toFixed(1) + '%';
        const julyPctText = (globalJulyRaise * 100).toFixed(1) + '%';
        document.getElementById('jan-raise-display').innerText = janPctText;
        document.getElementById('july-raise-display').innerText = julyPctText;
        
        const chartSub = document.getElementById('chart-subtitle-text');
        if(chartSub) {
            chartSub.innerHTML = `Baseline: Current Net Worth + Bi-Weekly Contributions (Full Dollar Raises Applied: <strong>${janPctText}</strong> Jan, <strong>${julyPctText}</strong> July)`;
        }

        if (data.length === 0) return;
        const latest = data[data.length - 1];
        const previous = data.length > 1 ? data[data.length - 2] : latest;
        
        globalLatestBaseSalary = latest.salary;
        globalPrevBaseSalary = previous.salary;
        
        document.getElementById('stat-salary-base').innerText = fmtMoney(latest.salary);
        document.getElementById('stat-salary-date').innerText = "Effective: " + latest.date;
        document.getElementById('stat-total-comp').innerText = fmtMoney(latest.totalComp);
        document.getElementById('stat-edu-ytd').innerText = fmtMoney(latest.ytdEdu || 0);
        document.getElementById('stat-match-rate').innerText = latest.matchPct + "%";

        const tbody = document.getElementById('salaryBody');
        tbody.innerHTML = '';
        [...data].reverse().forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td style="white-space:nowrap">${row.date}</td>
                <td style="font-weight:bold">${fmtMoney(row.salary)}</td>
                <td>${fmtMoney(row.matchAmt)} <span class="sub-text">(${row.matchPct}%)</span></td>
                <td>${row.ytdBonus > 0 ? fmtMoney(row.ytdBonus) : '-'} <span class="sub-text">(YTD)</span></td>
                <td>${row.ytdEdu > 0 ? fmtMoney(row.ytdEdu) : '-'} <span class="sub-text">(YTD)</span></td>
                <td style="font-weight:bold; color:var(--accent)">${fmtMoney(row.totalComp)}</td>
            `;
            tbody.appendChild(tr);
        });

        const labels = data.map(d => {
            const dt = new Date(d.date);
            return dt.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
        });

        const cSalary = palette[0];
        const cMatch = palette[2];
        const cEdu = palette[1];
        const cBonus = palette[4];
        
        // LEGEND PERSISTENCE
        let stHidden = [];
        if (charts.salaryTrend) {
            stHidden = charts.salaryTrend.data.datasets.map((d, i) => !charts.salaryTrend.isDatasetVisible(i));
            charts.salaryTrend.destroy();
        }

        charts.salaryTrend = new Chart(document.getElementById('salaryTrendChart'), {
            type: 'bar',
            plugins: [ChartDataLabels],
            data: {
                labels: labels,
                datasets: [
                    { 
                        label: 'Base Salary', data: data.map(d => d.salary), 
                        backgroundColor: cSalary + '88', borderColor: cSalary, borderWidth: 1, stack: 'Stack 0',
                        hidden: stHidden[0] ?? false 
                    }, 
                    { 
                        label: 'Company Match', data: data.map(d => d.matchAmt), 
                        backgroundColor: cMatch + '88', borderColor: cMatch, borderWidth: 1, stack: 'Stack 0',
                        hidden: stHidden[1] ?? false 
                    },
                    { 
                        label: 'Education (YTD)', data: data.map(d => d.ytdEdu), 
                        backgroundColor: cEdu + '88', borderColor: cEdu, borderWidth: 1, stack: 'Stack 0',
                        hidden: stHidden[2] ?? false 
                    },
                    { 
                        label: 'Bonus (YTD)', data: data.map(d => d.ytdBonus), 
                        backgroundColor: cBonus + '88', borderColor: cBonus, borderWidth: 1, stack: 'Stack 0',
                        hidden: stHidden[3] ?? false 
                    }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'top' },
                    datalabels: {
                        color: '#000000', 
                        font: { weight: 'bold', size: isMobile ? 6 : 8 }, 
                        rotation: isMobile ? -90 : 0,
                        display: 'auto',
                        formatter: (val) => val > 500 ? fmtMoneySimple(val) : ''
                    }
                },
                scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } }
            }
        });

        if (charts.compBreakdown) charts.compBreakdown.destroy();
        charts.compBreakdown = new Chart(document.getElementById('compBreakdownChart'), {
            type: 'doughnut',
            plugins: [ChartDataLabels],
            data: {
                labels: ['Base Salary', 'Match', 'Education (YTD)', 'Bonus (YTD)'],
                datasets: [{
                    data: [latest.salary, latest.matchAmt, latest.ytdEdu, latest.ytdBonus],
                    backgroundColor: [cSalary + '88', cMatch + '88', cEdu + '88', cBonus + '88'],
                    borderColor: [cSalary, cMatch, cEdu, cBonus],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'right' },
                    datalabels: {
                        color: '#000000', 
                        font: { weight: 'bold', size: isMobile ? 9 : 12 }, textAlign: 'center',
                        formatter: (val, ctx) => {
                            let sum = ctx.dataset.data.reduce((a, b) => a + b, 0);
                            let pct = ((val*100) / sum).toFixed(1) + "%";
                            return val > 0 ? fmtMoneySimple(val) + '\n(' + pct + ')' : '';
                        }
                    }
                }
            }
        });
    }

    // ==========================================
    // LOGIC: PROJECTION
    // ==========================================
    
    // UPDATED: Called by inputs, now uses Globals to force chart recalc instantly
    function handleUserProjectionChange() {
        if (g_lastBalance > 0 && g_lastDateStr) {
            renderProjectionChart(g_lastBalance, g_lastInflow, g_lastDateStr, true);
        }
    }

    function updateAllProjections() {
        updateExtrapolationCards();
        updateProjectionTable();
    }

    function updateProjectionTable() {
        const rate = parseFloat(document.querySelector('input[name="extrapolationRate"]:checked').value);
        const data = projectionDataStore[rate];
        const tbody = document.getElementById('projectionTableBody');
        tbody.innerHTML = '';

        if (!data) return;

        data.forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td style="font-weight:bold">${row.year}</td>
                <td style="color:#7f8c8d">${fmtMoney(row.startBal)}</td>
                <td style="color:#2980b9; font-weight:500;">
                    ${fmtMoney(row.annualContrib)}
                </td>
                <td style="color:#27ae60;">
                    +${fmtMoney(row.annualGrowth)}
                </td>
                <td style="font-weight:bold; color:var(--text); background:rgba(0,0,0,0.05);">
                    ${fmtMoney(row.endBal)}
                </td>
            `;
            tbody.appendChild(tr);
        });
    }

    function updateExtrapolationCards() {
        const rate = parseFloat(document.querySelector('input[name="extrapolationRate"]:checked').value);
        const meta = projectionMetadata[rate];

        if (!meta) return;

        document.getElementById('card-nw-label').innerText = `Projected Net Worth (${(rate*100).toFixed(1)}%)`;
        document.getElementById('proj-nw-card').innerHTML = `<div>${fmtMoneySimple(meta.finalLiquid)} <span style="font-size:0.6em; color:#7f8c8d">Liquid</span></div><div style="font-size:0.8em; margin-top:4px; color:var(--text)">${fmtMoneySimple(meta.totalNW)} <span style="font-size:0.8em; color:#7f8c8d">Total</span></div>`;
        
        document.getElementById('proj-porsche-date').innerText = meta.porscheDate ? meta.porscheDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }) : "Not Reached";
        document.getElementById('proj-porsche-countdown').innerText = formatCountdown(meta.porscheDate);
        document.getElementById('proj-porsche-sub').innerText = `Estimated Date (${(rate*100).toFixed(1)}% Rtn)`;

        document.getElementById('proj-house-date').innerText = meta.houseDate ? meta.houseDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }) : "Not Reached";
        document.getElementById('proj-house-countdown').innerText = formatCountdown(meta.houseDate);
        document.getElementById('proj-house-sub').innerText = `Estimated Date (${(rate*100).toFixed(1)}% Rtn)`;

        document.getElementById('custom-goal-display').innerText = fmtMoneySimple(meta.customGoal) + " Goal";
        document.getElementById('proj-custom-date').innerText = meta.customDate ? meta.customDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }) : "Not Reached";
        document.getElementById('proj-custom-countdown').innerText = formatCountdown(meta.customDate);
        document.getElementById('proj-custom-sub').innerText = `Estimated Date (${(rate*100).toFixed(1)}% Rtn)`;
    }

    function renderProjectionChart(startBalance, startInflow, startDateStr, isSilent = false) {
        const rates = [0.05, 0.075, 0.10, 0.125, 0.15];
        projectionDataStore = {};
        projectionMetadata = {};
        
        const customGoal = parseFloat(document.getElementById('customGoalInput').value) || 1000000;

        const currentYear = new Date().getFullYear();
        const endYear = currentYear + 25;
        
        const parts = startDateStr.split('-');
        let currentDate = new Date(parseInt(parts[0]), parseInt(parts[1])-1, 1);
        
        const anchorInput = document.getElementById('paydayAnchor');
        const anchorParts = anchorInput.value.split('-'); 
        
        let baselineMonthDate = new Date(currentDate);
        baselineMonthDate.setMonth(baselineMonthDate.getMonth() - 1); 
        
        let blStart = new Date(baselineMonthDate.getFullYear(), baselineMonthDate.getMonth(), 1);
        let blEnd = new Date(baselineMonthDate.getFullYear(), baselineMonthDate.getMonth() + 1, 0);
        let blTracker = new Date(parseInt(anchorParts[0]), parseInt(anchorParts[1])-1, parseInt(anchorParts[2]));
        
        while(blTracker > blStart) { blTracker.setDate(blTracker.getDate() - 14); }
        let paychecksInBaseline = 0;
        while(blTracker < blStart) { blTracker.setDate(blTracker.getDate() + 14); }
        while(blTracker <= blEnd) {
            paychecksInBaseline++;
            blTracker.setDate(blTracker.getDate() + 14);
        }
        
        if(paychecksInBaseline < 1) paychecksInBaseline = 2; 
        
        let paycheckAmount = startInflow / paychecksInBaseline;
        
        let raiseDelta = (globalLatestBaseSalary - globalPrevBaseSalary) / 26;
        if(raiseDelta < 0) raiseDelta = 0; 
        
        let displayPaycheckAmount = paycheckAmount + raiseDelta;
        
        const ppEl = document.getElementById('per-paycheck-amt');
        if(ppEl) ppEl.innerText = fmtMoney(displayPaycheckAmount);

        const labels = [];
        const timeline = [];
        
        let tempDate = new Date(currentDate);
        while (tempDate.getFullYear() < endYear || (tempDate.getFullYear() === endYear && tempDate.getMonth() <= 11)) {
            timeline.push(new Date(tempDate));
            labels.push(tempDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }));
            tempDate.setMonth(tempDate.getMonth() + 1);
        }

        const datasets = [];
        const projColors = [palette[0], palette[1], palette[2], palette[3], palette[4]];
        
        const annotations = {
            porscheLine: {
                type: 'line', yMin: 3, yMax: 3, borderColor: '#F39C12', borderWidth: 4, borderDash: [6, 4],
                label: { 
                    display: true, content: 'Porsche 911 (-$300k)', position: 'start', 
                    backgroundColor: 'rgba(243, 156, 18, 0.9)', color: 'white',
                    font: { size: isMobile ? 8 : 10, weight: 'bold' },  
                    yAdjust: -15, 
                    xAdjust: 10 
                }
            },
            houseLine: {
                type: 'line', yMin: 10, yMax: 10, borderColor: '#16A085', borderWidth: 4, borderDash: [6, 4],
                label: { 
                    display: true, content: 'Beach House (-$5M)', position: 'start', 
                    backgroundColor: 'rgba(22, 160, 133, 0.9)', color: 'white',
                    font: { size: isMobile ? 8 : 10, weight: 'bold' }, 
                    yAdjust: -15, 
                    xAdjust: 10 
                }
            }
        };

        rates.forEach((rate, idx) => {
            let balance = startBalance;
            let currentPaycheck = displayPaycheckAmount; 
            
            let modeledSalaryCheck = globalLatestBaseSalary / 26; 

            let payTracker = new Date(parseInt(anchorParts[0]), parseInt(anchorParts[1])-1, parseInt(anchorParts[2]));

            while(payTracker < timeline[0]) {
                 payTracker.setDate(payTracker.getDate() + 14);
            }

            let porscheBought = false, houseBought = false, customReached = false;
            let currentYearStats = { year: timeline[0].getFullYear(), startBal: balance, annualContrib: 0, annualGrowth: 0 };
            let yearlyData = [];
            
            let porscheDate = null;
            let houseDate = null;
            let customDate = null;

            const dataPoints = timeline.map((date, i) => {
                const year = date.getFullYear();
                if (year !== currentYearStats.year) {
                    currentYearStats.endBal = balance;
                    currentYearStats.annualGrowth = currentYearStats.endBal - currentYearStats.startBal - currentYearStats.annualContrib;
                    yearlyData.push({ ...currentYearStats });
                    currentYearStats = { year: year, startBal: balance, annualContrib: 0, annualGrowth: 0 };
                }

                if (i > 0) {
                    let raiseAmt = 0;
                    if (date.getMonth() === 0) {
                        raiseAmt = modeledSalaryCheck * globalJanRaise;
                        modeledSalaryCheck += raiseAmt;
                        currentPaycheck += raiseAmt;
                    }
                    if (date.getMonth() === 6) {
                        raiseAmt = modeledSalaryCheck * globalJulyRaise;
                        modeledSalaryCheck += raiseAmt;
                        currentPaycheck += raiseAmt;
                    }
                }

                let paychecksInMonth = 0;
                const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                
                while (payTracker <= monthEnd) {
                    if (payTracker >= monthStart) {
                        paychecksInMonth++;
                    }
                    payTracker.setDate(payTracker.getDate() + 14);
                }

                const monthlyContrib = currentPaycheck * paychecksInMonth;

                const growth = balance * (rate / 12);
                balance += growth;
                balance += monthlyContrib;
                currentYearStats.annualContrib += monthlyContrib;

                if (balance >= customGoal && !customReached) {
                    customReached = true;
                    customDate = date;
                }

                if (balance >= 3000000 && !porscheBought) {
                    balance -= 300000; porscheBought = true;
                    porscheDate = date;
                    annotations[`porsche_${idx}`] = { type: 'label', xValue: labels[i], yValue: 3, content: [`${year}`, `${(rate*100).toFixed(1)}%`], position: 'center', color: projColors[idx], font: { weight: 'bold', size: isMobile ? 6 : 8 }, yAdjust: -40 };
                }
                if (balance >= 10000000 && !houseBought) {
                    balance -= 5000000; houseBought = true;
                    houseDate = date;
                    annotations[`house_${idx}`] = { type: 'label', xValue: labels[i], yValue: 10, content: [`${year}`, `${(rate*100).toFixed(1)}%`], position: 'center', color: projColors[idx], font: { weight: 'bold', size: isMobile ? 6 : 8 }, yAdjust: -40 };
                }
                return balance / 1000000; 
            });

            currentYearStats.endBal = balance;
            currentYearStats.annualGrowth = currentYearStats.endBal - currentYearStats.startBal - currentYearStats.annualContrib;
            yearlyData.push({ ...currentYearStats });
            
            projectionDataStore[rate] = yearlyData;

            let finalBalance = balance;
            let assetValue = 0;
            if (porscheBought) assetValue += 300000;
            if (houseBought) assetValue += 5000000;
            let totalNW = finalBalance + assetValue;

            projectionMetadata[rate] = {
                finalLiquid: finalBalance,
                totalNW: totalNW,
                porscheDate: porscheDate,
                houseDate: houseDate,
                customDate: customDate,
                customGoal: customGoal
            };

            datasets.push({ label: (rate * 100).toFixed(1) + '%', data: dataPoints, borderColor: projColors[idx], backgroundColor: projColors[idx], borderWidth: 2, pointRadius: 0, tension: 0.4 });
        });

        updateAllProjections();

        if (charts.projection) charts.projection.destroy();
        charts.projection = new Chart(document.getElementById('projectionChart'), {
            type: 'line', data: { labels: labels, datasets: datasets },
            options: {
                animation: isSilent ? false : {}, 
                responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                plugins: { legend: { display: true, position: 'top' }, tooltip: { callbacks: { label: (ctx) => ctx.dataset.label + ': $' + ctx.raw.toFixed(2) + 'M' } }, annotation: { annotations: annotations } },
                scales: { 
                    y: { 
                        title: { display: true, text: 'Net Worth ($ Millions)' }, 
                        ticks: { callback: (val) => '$' + val + 'M', font: { size: isMobile ? 6 : 10 } } 
                    }, 
                    x: { 
                        title: { display: true, text: 'Year', font: {weight:'bold'} }, 
                        ticks: { maxTicksLimit: 20, font: { size: isMobile ? 6 : 10 }, callback: function(val) { const label = this.getLabelForValue(val); if (label.includes('Jan')) return label.split(' ')[1]; return null; } } 
                    } 
                }
            }
        });
    }

    // ==========================================
    // LOGIC: INVESTMENTS PARSING
    // ==========================================
    function parseSheetData(rows) {
        if (!rows) return [];
        const data = [];
        for (let i = 1; i < rows.length; i++) {
            const cols = rows[i];
            if (cols.length > 8) {
                const dateStr = cols[0];
                const deposits = cleanMoney(cols[2]);
                const withdrawals = cleanMoney(cols[3]); 
                const marketGain = cleanMoney(cols[4]);
                const income = cleanMoney(cols[5]);
                const cumulative = cleanMoney(cols[7]);
                const balance = cleanMoney(cols[8]);
                const invested = cols[9] ? cols[9].trim() : "Unknown";

                const dateParts = dateStr.split('/');
                if(dateParts.length < 2) continue;
                
                let month = dateParts[0].padStart(2, '0');
                let year = dateParts[2];
                const netTransfers = deposits + withdrawals;

                data.push({
                    key: `${year}-${month}`,
                    dateObj: new Date(year, month - 1, 1),
                    deposits: netTransfers,
                    rawDeposits: deposits, 
                    rawWithdrawals: withdrawals,
                    marketGain: marketGain,
                    income: income,
                    cumulative: cumulative,
                    balance: balance,
                    invested: invested
                });
            }
        }
        
        data.sort((a, b) => a.dateObj - b.dateObj);
        return data;
    }

    async function initDashboard() {
        try {
            document.getElementById('loading').innerHTML = "Loading Sheet Data...";
            const response = await fetch(API_URL);
            const rawData = await response.json();

            if (rawData.salary) {
                processSalaryData(rawData.salary);
            }

            const accounts = [
                { id: 'wellsFargo', name: 'Wells Fargo', data: parseSheetData(rawData.wellsFargo) },
                { id: 'fidelity', name: 'Fidelity', data: parseSheetData(rawData.fidelity) },
                { id: 'boeing', name: 'Boeing', data: parseSheetData(rawData.boeing) },
                { id: 'vanguardA', name: 'Vanguard Plan A', data: parseSheetData(rawData.vanguardA) },
                { id: 'vanguardB', name: 'Vanguard Plan B', data: parseSheetData(rawData.vanguardB) },
                { id: 'vanguardUTMA', name: 'Vanguard UTMA', data: parseSheetData(rawData.vanguardUTMA) }
            ];
            
            globalAccountsData = accounts;

            initPortfolioConfig();
            await updateWithLiveMarketData(accounts, false);

            processAndRender(accounts, false);
            
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 300);

            startAutoRefresh();

        } catch (error) {
            console.error(error);
            document.getElementById('loading').innerHTML = "Error loading data.<br>" + error.message;
        }
    }
    
    function isMarketOpen() {
        const now = new Date();
        const day = now.getDay();
        
        if (day === 0 || day === 6) return false;
        
        const etTime = now.toLocaleString("en-US", {timeZone: "America/New_York"});
        const etDate = new Date(etTime);
        const h = etDate.getHours();
        const m = etDate.getMinutes();
        
        const minutesOfDay = h * 60 + m;
        const start = 9 * 60 + 30; 
        const end = 16 * 60;       
        
        return minutesOfDay >= start && minutesOfDay < end;
    }

    function startAutoRefresh() {
        let isMarket = isMarketOpen();
        refreshTimer = isMarket ? 10 : 60;

        setInterval(() => {
            refreshTimer--;
            
            const currentMarketStatus = isMarketOpen();
            if (currentMarketStatus !== isMarket) {
                isMarket = currentMarketStatus;
            }
            
            if (refreshTimer <= 0) {
                console.log("Auto-Refreshing Market Data...");
                updateWithLiveMarketData(globalAccountsData, true); 
                processAndRender(globalAccountsData, true); 
                
                refreshTimer = isMarket ? 10 : 60;
            }
            
            document.getElementById('refresh-timer').innerText = `Updates in ${refreshTimer}s`;
        }, 1000);
    }

    function createSnapshotTable(accounts, alignedData, index, tableId, headerId, monthKey) {
        const body = document.getElementById(tableId);
        body.innerHTML = '';
        
        if (headerId && monthKey) {
            const parts = monthKey.split('-');
            const d = new Date(parseInt(parts[0]), parseInt(parts[1])-1, 1);
            const prettyDate = d.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            document.getElementById(headerId).innerText = `${prettyDate} Breakdown`;
        }

        if (index < 0) {
            body.innerHTML = '<tr><td colspan="7" style="text-align:center">No Data Available for this period</td></tr>';
            return;
        }
        
        let sumBal = 0;
        let sumGain = 0;
        let sumInflow = 0;
        let sumNetDep = 0;
        let sumCum = 0;

        accounts.forEach(acc => {
            const entry = alignedData[acc.id][index];
            if (entry.balance < 0.01) return;
            
            sumBal += entry.balance;
            sumGain += (entry.marketGain + entry.income);
            sumInflow += (entry.deposits + entry.income);
            const totalNetDep = entry.balance - entry.cumulative;
            sumNetDep += totalNetDep;
            sumCum += entry.cumulative;

            const tr = document.createElement('tr');
            if(entry.isLive) {
                tr.style.backgroundColor = isSciFiMode ? 'rgba(255, 255, 0, 0.05)' : "#fef9e7"; 
            }

            let roiPct = 0;
            if (totalNetDep !== 0) { roiPct = (entry.cumulative / totalNetDep) * 100; }
            const roiColor = roiPct >= 0 ? 'text-green' : 'text-red';
            const roiText = (roiPct >= 0 ? '+' : '') + roiPct.toFixed(1) + '%';
            
            const liveTag = entry.isLive ? '<span style="background:red; color:white; font-size:9px; padding:1px 3px; border-radius:3px; margin-left:5px; vertical-align:middle;">LIVE</span>' : '';
            
            let marketGainDisplay = "";
            let dailyBadge = "";
            
            // Override display in snapshot
            let displayTicker = entry.invested;
            if(accountOverrides[acc.id]) displayTicker = accountOverrides[acc.id].ticker + " (Ovrd)";

            if (entry.isError) {
                marketGainDisplay = '<span style="color:#e74c3c; font-style:italic; font-size:0.9em;">Unavailable</span>';
            } else {
                 const isZero = (entry.marketGain === 0);
                 const gainClass = entry.marketGain >= 0 ? 'text-green' : 'text-red';
                 const gainText = (entry.marketGain >= 0 ? '+' : '') + fmtMoney(entry.marketGain + entry.income);
                 
                 let oneMoPct = 0;
                 const estimatedStartBal = entry.balance - (entry.marketGain + entry.income); 
                 if(estimatedStartBal > 0) {
                     oneMoPct = ((entry.marketGain + entry.income) / estimatedStartBal) * 100;
                 }
                 const pctText = ` <span style="font-size:0.8em; opacity:0.8">(${oneMoPct >= 0 ? '+' : ''}${oneMoPct.toFixed(1)}%)</span>`;
                 
                 if(entry.isLive) {
                     const dataDate = new Date(entry.timestamp * 1000);
                     const dateStr = dataDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

                     const today = new Date();
                     const isSameDay = dataDate.getDate() === today.getDate() && dataDate.getMonth() === today.getMonth();
                     
                     const dotClass = isSameDay ? 'status-updated' : 'status-pending';
                     
                     dailyBadge = `<br><span class="daily-tag"><span class="status-dot ${dotClass}" title="NAV Date"></span>${dateStr}</span>`;
                 }
                 
                 marketGainDisplay = `<span class="${gainClass}">${gainText}${pctText}</span>`;
            }

            tr.innerHTML = `
                <td>
                    <span class="account-name">${acc.name}${liveTag}</span>
                    <span class="ticker-tag">${displayTicker}</span>
                </td>
                <td style="font-weight:bold">${fmtMoney(entry.balance)}</td>
                <td>
                    ${marketGainDisplay}${dailyBadge}
                </td>
                <td>
                    ${fmtMoney(entry.deposits + entry.income)}
                </td>
                <td>${fmtMoney(totalNetDep)}</td>
                <td style="font-weight:bold" class="${entry.cumulative >= 0 ? 'text-green' : 'text-red'}">
                    ${fmtMoney(entry.cumulative)}
                </td>
                <td style="font-weight:bold" class="${roiColor}">${roiText}</td>
            `;
            body.appendChild(tr);
        });
        
        let totalRoi = 0;
        if (sumNetDep !== 0) totalRoi = (sumCum / sumNetDep) * 100;
        
        let totalOneMoPct = 0;
        const totalEstStartBal = sumBal - sumGain;
        if (totalEstStartBal > 0) {
            totalOneMoPct = (sumGain / totalEstStartBal) * 100;
        }
        const totalPctText = ` <span style="font-size:0.8em; opacity:0.8">(${totalOneMoPct >= 0 ? '+' : ''}${totalOneMoPct.toFixed(1)}%)</span>`;
        
        const totalTr = document.createElement('tr');
        totalTr.style.fontWeight = 'bold';
        totalTr.style.backgroundColor = isSciFiMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
        totalTr.innerHTML = `
            <td>TOTAL</td>
            <td>${fmtMoney(sumBal)}</td>
            <td class="${sumGain >= 0 ? 'text-green' : 'text-red'}">
                ${(sumGain >= 0 ? '+' : '') + fmtMoney(sumGain)}${totalPctText}
            </td>
            <td>${fmtMoney(sumInflow)}</td>
            <td>${fmtMoney(sumNetDep)}</td>
            <td class="${sumCum >= 0 ? 'text-green' : 'text-red'}">${fmtMoney(sumCum)}</td>
            <td class="${totalRoi >= 0 ? 'text-green' : 'text-red'}">${(totalRoi >= 0 ? '+' : '') + totalRoi.toFixed(1)}%</td>
        `;
        body.appendChild(totalTr);
    }

    function renderWellsFargoWidget(accounts, isSilent = false) {
        const wf = accounts.find(a => a.id === 'wellsFargo');
        if (!wf) return;
        
        const relevantData = wf.data.filter(d => !d.isLive).slice(-24);
        
        const labels = relevantData.map(d => d.key);
        const values = relevantData.map(d => Math.abs(d.rawWithdrawals)); 
        
        const cRed = palette[5];

        if (charts.wfWithdrawal) charts.wfWithdrawal.destroy();
        charts.wfWithdrawal = new Chart(document.getElementById('wfWithdrawalChart'), {
            type: 'bar',
            plugins: [ChartDataLabels],
            data: {
                labels: labels,
                datasets: [{
                    label: 'Monthly Withdrawals',
                    data: values,
                    backgroundColor: cRed + '88', 
                    borderColor: cRed,
                    borderWidth: 1,
                    borderRadius: 2,
                    barPercentage: 1.0, 
                    categoryPercentage: 1.0 
                }]
            },
            options: {
                animation: isSilent ? false : {}, 
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    datalabels: {
                        color: '#2c3e50',
                        anchor: isMobile ? 'end' : 'end', 
                        align: isMobile ? 'top' : 'end', 
                        rotation: isMobile ? -90 : 0,    
                        font: { weight: 'bold', size: 9 },
                        formatter: (val) => val > 200 ? fmtMoneySimple(val) : '' 
                    }
                },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#f0f0f0' }, ticks: { font: { size: 9 } } },
                    x: { grid: { display: false }, ticks: { font: { size: 8 }, maxRotation: 90, minRotation: 90 } }
                }
            }
        });
    }

    function initIncomeAnalysis(accounts) {
        const container = document.getElementById('income-filter-container');
        
        if (container.children.length > 1) return; 

        const defaultIds = ['wellsFargo', 'vanguardUTMA', 'vanguardA', 'vanguardB'];

        accounts.forEach(acc => {
            const label = document.createElement('label');
            label.className = 'checkbox-item';
            const isChecked = defaultIds.includes(acc.id) ? 'checked' : '';
            label.innerHTML = `<input type="checkbox" value="${acc.id}" ${isChecked} onchange="updateIncomeAnalysis()"> ${acc.name}`;
            container.appendChild(label);
        });

        updateIncomeAnalysis(false); 
    }

    function updateIncomeAnalysis(isSilent = false) {
        const checkboxes = document.querySelectorAll('#income-filter-container input[type="checkbox"]');
        const selectedIds = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);

        const targetAccounts = globalAccountsData.filter(a => selectedIds.includes(a.id));
        
        const allMonths = new Set();
        globalAccountsData.forEach(acc => acc.data.forEach(d => { if(!d.isLive) allMonths.add(d.key); }));
        const sortedMonths = Array.from(allMonths).sort().slice(-24); 

        const incomeData = sortedMonths.map(month => {
            let sum = 0;
            targetAccounts.forEach(acc => {
                const entry = acc.data.find(d => d.key === month);
                if (entry) sum += entry.rawDeposits;
            });
            return sum;
        });

        const last12Data = incomeData.slice(-12);
        const trailing12Sum = last12Data.reduce((a,b) => a+b, 0);
        document.getElementById('stat-12mo-income').innerText = fmtMoneySimple(trailing12Sum);

        const cGreen = palette[2];

        if(charts.incomeTrend) charts.incomeTrend.destroy();

        charts.incomeTrend = new Chart(document.getElementById('incomeTrendChart'), {
            type: 'bar',
            plugins: [ChartDataLabels],
            data: {
                labels: sortedMonths,
                datasets: [{
                    label: 'Total After-Tax Deposits',
                    data: incomeData,
                    backgroundColor: cGreen + '88',
                    borderColor: cGreen,
                    borderWidth: 1,
                    borderRadius: 3,
                    barPercentage: 1.0, 
                    categoryPercentage: 1.0 
                }]
            },
            options: {
                animation: isSilent ? false : {}, 
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    datalabels: {
                        color: '#2c3e50',
                        anchor: isMobile ? 'end' : 'end', 
                        align: isMobile ? 'top' : 'end', 
                        rotation: isMobile ? -90 : 0,    
                        font: { weight: 'bold', size: 9 },
                        formatter: (val) => val > 500 ? fmtMoneySimple(val) : ''
                    }
                },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#f0f0f0' }, ticks: { font: { size: 9 } } },
                    x: { grid: { display: false }, ticks: { font: { size: 8 }, maxRotation: 90, minRotation: 90 } }
                }
            }
        });
    }

    function processAndRender(accounts, isSilent = false) {
        const allMonths = new Set();
        accounts.forEach(acc => acc.data.forEach(d => allMonths.add(d.key)));
        const sortedMonths = Array.from(allMonths).sort();

        const alignedData = {};
        const globalTotals = { balance: [], gainLoss: [], income: [], deposits: [], cumulative: [] };
        
        accounts.forEach(acc => alignedData[acc.id] = []);
        
        // --- YEARLY DATA (TWR) AGGREGATION SETUP ---
        // We will compute Linked Monthly Returns: Product(1 + Rm) - 1
        const yearlyTwr = new Map();

        sortedMonths.forEach((monthKey, i) => {
            let monthBalance = 0, monthGain = 0, monthIncome = 0, monthDeposits = 0, monthCumulative = 0;

            accounts.forEach(acc => {
                const entry = acc.data.find(d => d.key === monthKey);
                if (entry) {
                    alignedData[acc.id].push(entry);
                    monthBalance += entry.balance;
                    monthGain += entry.marketGain + entry.income; 
                    monthIncome += entry.income;
                    monthDeposits += entry.deposits;
                    monthCumulative += entry.cumulative;
                } else {
                    alignedData[acc.id].push({ balance: 0, marketGain: 0, income: 0, deposits: 0, cumulative: 0, invested: '-', rawWithdrawals: 0 });
                }
            });

            globalTotals.balance.push(monthBalance);
            globalTotals.gainLoss.push(monthGain);
            globalTotals.income.push(monthIncome);
            globalTotals.deposits.push(monthDeposits);
            globalTotals.cumulative.push(monthCumulative);
            
            // --- HIGH ACCURACY MONTHLY RETURN CALCULATION ---
            const year = monthKey.split('-')[0];
            if(!yearlyTwr.has(year)) {
                yearlyTwr.set(year, 1.0); 
            }
            
            // Determine Start Balance for this Month
            // If i=0, we assume start balance was (End - Gain - NetTransfers)
            // Otherwise, start balance is previous month's end balance
            let startBal = (i === 0) ? (monthBalance - monthGain - monthDeposits) : globalTotals.balance[i-1];
            
            // Handle edge case where account is empty/just started
            if (startBal < 0) startBal = 0; 

            // Modified Dietz for Monthly Period:
            // Numerator: Gain (Market Gain + Income)
            // Denominator: Start Balance + 0.5 * External Flows (Deposits)
            // Note: 'monthDeposits' here is Net Transfers. 
            let denominator = startBal + (0.5 * monthDeposits);
            
            let monthlyReturn = 0;
            if (denominator > 0) {
                monthlyReturn = monthGain / denominator;
            } else if (monthGain !== 0) {
                 // Edge case: gain with 0 denominator (e.g. infinite return on 0 base)
                 // We cap or ignore to prevent chart explosion, or treat as pure gain if start is 0
                 monthlyReturn = 0; 
            }
            
            // Link Geometrically
            let currentTwr = yearlyTwr.get(year);
            yearlyTwr.set(year, currentTwr * (1 + monthlyReturn));
        });
        
        // --- YEARLY CHART DATA ---
        const yearlyLabels = Array.from(yearlyTwr.keys());
        const yearlyReturns = [];
        let sumPct = 0;
        
        yearlyLabels.forEach(y => {
            const val = yearlyTwr.get(y);
            const pct = (val - 1) * 100; // Convert (1.15) -> 15%
            yearlyReturns.push(pct);
            sumPct += pct;
        });
        
        const avgReturn = yearlyReturns.length ? sumPct / yearlyReturns.length : 0;
        const avgEl = document.getElementById('stat-avg-yearly-return');
        if(avgEl) {
            avgEl.innerText = (avgReturn >= 0 ? '+' : '') + avgReturn.toFixed(2) + '%';
            avgEl.className = avgReturn >= 0 ? 'text-green' : 'text-red';
            avgEl.style.fontSize = "1.5em";
            avgEl.style.fontWeight = "bold";
        }

        const lastIndex = sortedMonths.length - 1;
        
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        document.getElementById('latest-date-display').innerHTML = `<span class="live-dot"></span>Data as of ${sortedMonths[lastIndex]} (${timeString})`;
        document.getElementById('latest-date-display').style.color = "#c0392b"; 
        
        document.getElementById('stat-networth').innerText = fmtMoney(globalTotals.balance[lastIndex]);
        
        const totalGain = globalTotals.cumulative[lastIndex];
        const gainEl = document.getElementById('stat-lifetime-gain');
        
        let netInvested = globalTotals.balance[lastIndex] - totalGain;
        let lifetimePct = 0;
        if(netInvested !== 0) {
            lifetimePct = (totalGain / netInvested) * 100;
        }
        
        const lifetimePctText = ` <span style="font-size:0.6em; opacity:0.8">(${lifetimePct >= 0 ? '+' : ''}${lifetimePct.toFixed(1)}%)</span>`;
        gainEl.innerHTML = (totalGain >= 0 ? '+' : '') + fmtMoney(totalGain) + lifetimePctText;
        gainEl.className = 'stat-value ' + (totalGain >= 0 ? 'text-green' : 'text-red');

        const monthlyPL = globalTotals.gainLoss[lastIndex];
        const plEl = document.getElementById('stat-monthly-pl');
        
        let estMonthlyStart = globalTotals.balance[lastIndex] - monthlyPL;
        let monthlyPct = 0;
        if (estMonthlyStart !== 0) {
            monthlyPct = (monthlyPL / estMonthlyStart) * 100;
        }
        
        const monthlyPctText = ` <span style="font-size:0.6em; opacity:0.8">(${monthlyPct >= 0 ? '+' : ''}${monthlyPct.toFixed(1)}%)</span>`;
        plEl.innerHTML = (monthlyPL >= 0 ? '+' : '') + fmtMoney(monthlyPL) + monthlyPctText;
        plEl.className = 'stat-value ' + (monthlyPL >= 0 ? 'text-green' : 'text-red');

        const lastIncome = globalTotals.income[lastIndex];
        const lastDeposits = globalTotals.deposits[lastIndex];
        const totalInflow = lastIncome + lastDeposits;
        
        document.getElementById('stat-monthly-inflow').innerText = fmtMoney(totalInflow);
        document.getElementById('stat-monthly-inflow-sub').innerHTML = `Income: ${fmtMoney(lastIncome)} <span style="margin:0 4px; color:#ccc">|</span> Net Dep: ${fmtMoney(lastDeposits)}`;

        let investmentInflow = 0;
        if (lastIndex > 0) {
            const baselineMonth = sortedMonths[lastIndex - 1]; 
            accounts.forEach(acc => {
                if (acc.id === 'vanguardA' || acc.id === 'vanguardB' || acc.id === 'fidelity') {
                    const entry = alignedData[acc.id].find(d => d.key === baselineMonth);
                    if (entry) {
                        investmentInflow += entry.deposits + entry.income;
                    }
                }
            });
        } else {
            investmentInflow = totalInflow; 
        }
        
        // STORE GLOBAL STATE FOR INSTANT RECALC
        g_lastBalance = globalTotals.balance[lastIndex];
        g_lastInflow = investmentInflow;
        g_lastDateStr = sortedMonths[lastIndex];

        renderProjectionChart(globalTotals.balance[lastIndex], investmentInflow, sortedMonths[lastIndex], isSilent);

        const stackedDatasets = accounts.map((acc, index) => {
            const color = palette[index % palette.length];
            return {
                label: acc.name,
                data: alignedData[acc.id].map(d => d.balance),
                backgroundColor: color + '88', borderColor: color, borderWidth: 1, fill: true, tension: 0.2
            };
        });
        
        createSnapshotTable(accounts, alignedData, lastIndex, 'snapshotBody', 'currentSnapshotHeader', sortedMonths[lastIndex]);
        createSnapshotTable(accounts, alignedData, lastIndex - 1, 'prevSnapshotBody', 'prevSnapshotHeader', sortedMonths[lastIndex-1]);
        
        renderWellsFargoWidget(accounts, isSilent);

        initIncomeAnalysis(accounts);
        updateIncomeAnalysis(isSilent);

        const allocation = {};
        accounts.forEach(acc => {
            const latest = alignedData[acc.id][lastIndex];
            if (latest.balance > 0) {
                // Check override
                const override = accountOverrides[acc.id];
                const ticker = override && override.ticker ? override.ticker : latest.invested;
                allocation[ticker] = (allocation[ticker] || 0) + latest.balance;
            }
        });
        const allocLabels = Object.keys(allocation);
        const allocValues = Object.values(allocation);
        const totalPortfolio = allocValues.reduce((a, b) => a + b, 0);

        if (charts.allocation) charts.allocation.destroy();
        charts.allocation = new Chart(document.getElementById('allocationChart'), {
            type: 'doughnut', plugins: [ChartDataLabels],
            data: { 
                labels: allocLabels, 
                datasets: [{ 
                    data: allocValues, 
                    backgroundColor: palette.map(c => c + '88'), 
                    borderColor: palette, 
                    borderWidth: 1
                }] 
            },
            options: { 
                animation: isSilent ? false : {}, 
                maintainAspectRatio: false, layout: { padding: 80 }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => ctx.label + ': ' + fmtMoney(ctx.raw) + ' (' + ((ctx.raw/totalPortfolio)*100).toFixed(1) + '%)' } }, 
                datalabels: { 
                    color: '#2c3e50', 
                    anchor: 'end', 
                    align: 'end', 
                    offset: 10, 
                    formatter: (val, ctx) => {
                        const pct = ((val/totalPortfolio)*100).toFixed(1) + '%';
                        return (val/totalPortfolio > 0.01) ? ctx.chart.data.labels[ctx.dataIndex] + '\n' + fmtMoneySimple(val) + '\n(' + pct + ')' : '';
                    }
                } 
            } }
        });

        // LEGEND PERSISTENCE (BALANCE CHART)
        let balHidden = [];
        if (charts.balance) {
            balHidden = charts.balance.data.datasets.map((d, i) => !charts.balance.isDatasetVisible(i));
            charts.balance.destroy();
        }

        const persistentDatasets = stackedDatasets.map((ds, i) => ({
            ...ds,
            hidden: balHidden[i] ?? false
        }));

        charts.balance = new Chart(document.getElementById('balanceChart'), {
            type: 'line', plugins: [ChartDataLabels],
            data: { labels: sortedMonths, datasets: persistentDatasets },
            options: {
                animation: isSilent ? false : {}, 
                responsive: true, maintainAspectRatio: false, layout: { padding: { right: isMobile ? 90 : 150 } }, interaction: { mode: 'index', intersect: false },
                plugins: { legend: { align: isMobile ? 'start' : 'center', position: 'top', labels: { boxWidth: isMobile ? 12 : 40, padding: 10 } }, datalabels: { align: 'right', anchor: 'end', offset: 5, backgroundColor: 'white', borderColor: (ctx) => ctx.dataset.borderColor, borderWidth: 1, borderRadius: 4, padding: isMobile ? 4 : 6, color: 'black', font: { weight: 'bold', size: isMobile ? 9 : 10 }, formatter: (val, ctx) => (ctx.dataIndex === ctx.dataset.data.length - 1 && val > 500) ? ctx.dataset.label + '\n' + fmtMoneySimple(val) : null, display: (ctx) => ctx.dataIndex === ctx.dataset.data.length - 1 } },
                scales: { y: { beginAtZero: true, stacked: true } }
            }
        });

        // ==========================================
        // SLIDER PERSISTENCE LOGIC
        // ==========================================
        const slider = document.getElementById('balanceSlider');
        let persistedStart = 0;
        let persistedEnd = sortedMonths.length - 1;
        let shouldPreserve = false;

        if (slider && slider.noUiSlider) {
            const currentVals = slider.noUiSlider.get();
            const currentStartIdx = parseInt(currentVals[0]);
            const currentEndIdx = parseInt(currentVals[1]);
            const wasAtRightEdge = (currentEndIdx >= (sortedMonths.length - 2)); 

            persistedStart = currentStartIdx;
            
            if (wasAtRightEdge) {
                persistedEnd = sortedMonths.length - 1; 
            } else {
                persistedEnd = currentEndIdx; 
            }
            
            if(persistedStart < 0) persistedStart = 0;
            if(persistedEnd >= sortedMonths.length) persistedEnd = sortedMonths.length - 1;
            
            shouldPreserve = true;
            slider.noUiSlider.destroy();
        }

        noUiSlider.create(slider, {
            start: shouldPreserve ? [persistedStart, persistedEnd] : [0, sortedMonths.length - 1], 
            connect: true,
            range: {
                'min': 0,
                'max': sortedMonths.length - 1
            },
            step: 1, 
            tooltips: {
                to: (val) => sortedMonths[Math.round(val)],
                from: (val) => val
            }
        });

        slider.noUiSlider.on('update', function (values, handle) {
            const minIdx = Math.round(values[0]);
            const maxIdx = Math.round(values[1]);
            
            charts.balance.options.scales.x.min = sortedMonths[minIdx];
            charts.balance.options.scales.x.max = sortedMonths[maxIdx];
            charts.balance.update();
        });

        const cGreen = palette[2];
        const cRed = palette[5];

        if (charts.pl) charts.pl.destroy();
        charts.pl = new Chart(document.getElementById('plChart'), {
            type: 'bar',
            data: { 
                labels: sortedMonths, 
                datasets: [{ 
                    label: 'Monthly Net Gain/Loss', 
                    data: globalTotals.gainLoss, 
                    backgroundColor: globalTotals.gainLoss.map(v => v >= 0 ? cGreen + '88' : cRed + '88'),
                    borderColor: globalTotals.gainLoss.map(v => v >= 0 ? cGreen : cRed),
                    borderWidth: 1
                }] 
            },
            options: { 
                animation: isSilent ? false : {}, 
                responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { grid: { color: '#f0f0f0' } }, x: { grid: { display: false } } } 
            }
        });
        
        // --- YEARLY CHART RENDER ---
        if (charts.yearly) charts.yearly.destroy();
        charts.yearly = new Chart(document.getElementById('yearlyReturnChart'), {
            type: 'bar',
            plugins: [ChartDataLabels],
            data: { 
                labels: yearlyLabels, 
                datasets: [{ 
                    label: 'Yearly Return %', 
                    data: yearlyReturns, 
                    backgroundColor: yearlyReturns.map(v => v >= 0 ? cGreen + '88' : cRed + '88'),
                    borderColor: yearlyReturns.map(v => v >= 0 ? cGreen : cRed),
                    borderWidth: 1,
                    borderRadius: 4
                }] 
            },
            options: { 
                animation: isSilent ? false : {}, 
                responsive: true, maintainAspectRatio: false, 
                plugins: { 
                    legend: { display: false },
                    datalabels: {
                        color: '#2c3e50',
                        anchor: 'end', 
                        align: 'end', 
                        offset: -5,
                        font: { weight: 'bold', size: 9 }, // UPDATED FONT SIZE
                        formatter: (val) => val.toFixed(1) + '%'
                    }
                }, 
                scales: { 
                    y: { 
                        grid: { color: '#f0f0f0' },
                        ticks: { callback: (val) => val + '%', font: { size: 9 } }
                    }, 
                    x: { grid: { display: false }, ticks: { font: { size: 9 } } } 
                } 
            }
        });

        const historyHeader = document.getElementById('historyHeader');
        historyHeader.innerHTML = '<th>Month</th><th>Total Balance</th><th>Total Gain/Loss</th>';
        accounts.forEach(acc => {
            const th = document.createElement('th');
            th.innerText = acc.name.split(' ')[0]; th.style.fontSize = "0.8em"; historyHeader.appendChild(th);
        });

        const historyBody = document.getElementById('historyBody');
        historyBody.innerHTML = '';
        for (let i = sortedMonths.length - 1; i >= 0; i--) {
            const tr = document.createElement('tr');
            
            const histVal = globalTotals.gainLoss[i];
            const histBal = globalTotals.balance[i];
            let histEstStart = histBal - histVal;
            let histPct = 0;
            if(histEstStart !== 0) {
                histPct = (histVal / histEstStart) * 100;
            }
            const histPctText = ` <span style="font-size:0.8em; opacity:0.7">(${histPct >= 0 ? '+' : ''}${histPct.toFixed(1)}%)</span>`;
            
            tr.innerHTML = `<td>${sortedMonths[i]}</td><td style="font-weight:bold">${fmtMoney(histBal)}</td><td class="${histVal >= 0 ? 'text-green' : 'text-red'}">${histVal >= 0 ? '+' : ''}${fmtMoney(histVal)}${histPctText}</td>`;
            accounts.forEach(acc => {
                const val = alignedData[acc.id][i].balance;
                const td = document.createElement('td');
                td.innerText = val ? fmtMoney(val) : '-'; td.style.fontSize = "0.85em"; tr.appendChild(td);
            });
            historyBody.appendChild(tr);
        }
        
        updateChartStyles();
    }
    
    initDashboard();

</script>
</body>
</html>
